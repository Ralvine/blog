<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>笔记 - 分类 - 暮瞻</title>
        <link>https://blog.ralvines.top/categories/%E7%AC%94%E8%AE%B0/</link>
        <description>笔记 - 分类 - 暮瞻</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 30 Oct 2023 20:20:40 &#43;0800</lastBuildDate><atom:link href="https://blog.ralvines.top/categories/%E7%AC%94%E8%AE%B0/" rel="self" type="application/rss+xml" /><item>
    <title>分类问题中的 k 近邻法</title>
    <link>https://blog.ralvines.top/knn/</link>
    <pubDate>Mon, 30 Oct 2023 20:20:40 &#43;0800</pubDate><author>
                        <name>Ralvine</name><uri>https://blog.ralvines.top/about/praise/</uri><email>ralvine@163.com</email></author><guid>https://blog.ralvines.top/knn/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://z1.ax1x.com/2023/11/01/piuKE6K.png" referrerpolicy="no-referrer">
            </div><h2 id="分类问题1" class="headerLink">
    <a href="#%e5%88%86%e7%b1%bb%e9%97%ae%e9%a2%981" class="header-mark"></a>分类问题<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></h2><ul>
<li>
<p>一种监督学习问题，旨在对数据分类</p>
</li>
<li>
<p>将输入数据映射到预定义的类别或标签</p>
</li>
<li>
<p>从已知的训练数据中学习一个分类模型，然后将该模型应用于新的、未知的数据，以预测其所属的类别</p>
</li>
<li>
<p>垃圾邮件过滤、金融风险评估</p>
</li>
<li>
<p>医学诊断、生物信息学</p>
</li>
<li>
<p>情感分析、客户分类</p>
</li>
<li>
<p>图像识别</p>
</li>
</ul>
<h2 id="knn模型构建" class="headerLink">
    <a href="#knn%e6%a8%a1%e5%9e%8b%e6%9e%84%e5%bb%ba" class="header-mark"></a>kNN模型构建</h2><h3 id="提出2" class="headerLink">
    <a href="#%e6%8f%90%e5%87%ba2" class="header-mark"></a>提出<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></h3><p>$$T={(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)}$$
$$y_i\in\mathcal{Y}={c_1,c_2,\cdots,c_K}$$
$$y=\text{arg}\max\limits_{c_j} \sum\limits_{x_i\in N_k(x)} I(y_i=c_j)$$</p>
<ul>
<li>
<p>输入：特征向量（空间点）</p>
</li>
<li>
<p>输出：类别（可以取多类）</p>
</li>
<li>
<p>已标注的训练集</p>
</li>
<li>
<p>预测：多数表决（“近朱者赤” ）</p>
</li>
<li>
<p>不具有显式的学习过程</p>
</li>
</ul>
<p><strong>适用范围</strong></p>
<ul>
<li>数值型和标称型<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup></li>
</ul>
<p><strong>优点</strong><sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup><sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup></p>
<ol>
<li>直观、非参数化</li>
<li>对异常值不敏感</li>
<li>支持多类别</li>
</ol>
<p><strong>缺点</strong><sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup></p>
<ol>
<li>时间复杂度高</li>
<li>存储成本高</li>
<li>“维度灾难”和数据不平衡</li>
</ol>
<h3 id="构建流程" class="headerLink">
    <a href="#%e6%9e%84%e5%bb%ba%e6%b5%81%e7%a8%8b" class="header-mark"></a>构建流程</h3><p>给定距离度量，k值与决策规则 [输入训练集T]</p>
<ol>
<li>在训练集 T 中找出与 x 最邻近的 k 个点，涵盖这 个点的 x 的邻域记作 $N_k(a)$</li>
<li>在 $N_k(a)$ 中根据分类决策规则决定 x 的类别 y</li>
</ol>
<p><strong>基本要素</strong></p>
<ol>
<li>k 值选择</li>
<li>距离度量</li>
<li>决策规则</li>
</ol>
<a class="lightgallery" href="https://z1.ax1x.com/2023/11/01/piuKE6K.png" data-thumbnail="https://z1.ax1x.com/2023/11/01/piuKE6K.png">
</a>
<p class="img-desc" style="text-align: center">▲ 特征空间划分。</p>
<p>特殊情况：最近邻（k=1）</p>
<h2 id="模型要素" class="headerLink">
    <a href="#%e6%a8%a1%e5%9e%8b%e8%a6%81%e7%b4%a0" class="header-mark"></a>模型要素</h2><h3 id="k-值选择" class="headerLink">
    <a href="#k-%e5%80%bc%e9%80%89%e6%8b%a9" class="header-mark"></a>k 值选择</h3><table>
<thead>
<tr>
<th>k值</th>
<th>偏小</th>
<th>偏大</th>
</tr>
</thead>
<tbody>
<tr>
<td>近似误差</td>
<td>减小</td>
<td>增大</td>
</tr>
<tr>
<td>估计误差</td>
<td>增大</td>
<td>减小</td>
</tr>
</tbody>
</table>
<p>交叉验证以提高泛化性能。<sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup></p>
<h3 id="距离度量9" class="headerLink">
    <a href="#%e8%b7%9d%e7%a6%bb%e5%ba%a6%e9%87%8f9" class="header-mark"></a>距离度量<sup id="fnref:8"><a href="#fn:8" class="footnote-ref" role="doc-noteref">8</a></sup></h3><p>对于
$$x_i=(x_i^{(1)}, x_i^{(2)}, \cdots, x_i^{(n)})$$</p>
<ul>
<li>$L_p$ 距离
$$L_p(x_i,x_j)=(\sum\limits_{l=1}^n |x_i^{(l)}-x_j^{(l)}|^p)^{1/p}$$</li>
<li>欧氏距离
$$L_2(x_i,x_j)=(\sum\limits_{l=1}^n |x_i^{(l)}-x_j^{(l)}|^2)^{1/2}$$</li>
<li>曼哈顿距离
$$L_1(x_i,x_j)=\sum\limits_{l=1}^n |x_i^{(l)}-x_j^{(l)}|$$</li>
<li>$L_\infty$ 距离
$$L_\infty (x_i,x_j)=\max\limits_l |x_i^{(l)}-x_j^{(l)}|$$</li>
</ul>
<h3 id="决策规则" class="headerLink">
    <a href="#%e5%86%b3%e7%ad%96%e8%a7%84%e5%88%99" class="header-mark"></a>决策规则</h3><p><strong>多数表决</strong>
由输入实例的 k 个邻近的训练实例中的多数类决定输入实例的类。</p>
<ul>
<li>分类函数
$$f:\mathbb{R}^n\rightarrow {c_1,c_2,\cdots,c_K}$$</li>
<li>误分类概率
$$P(Y\ne f(X))=1-P(Y=f(X))$$</li>
<li>等价于风险经验最小化
$$\frac{1}{k}\sum\limits_{x_i\in N_k(x)} I(y_i\ne c_j)=1-\frac{1}{k}\sum\limits_{x_i\in N_k(x)} I(y_i=c_j)$$</li>
</ul>
<h2 id="模型预测" class="headerLink">
    <a href="#%e6%a8%a1%e5%9e%8b%e9%a2%84%e6%b5%8b" class="header-mark"></a>模型预测</h2><h3 id="预测流程" class="headerLink">
    <a href="#%e9%a2%84%e6%b5%8b%e6%b5%81%e7%a8%8b" class="header-mark"></a>预测流程</h3><p>首先引入最简单的思路：线性扫描的方法。</p>
<a class="lightgallery" href="https://z1.ax1x.com/2023/11/01/piuKkSx.png" data-thumbnail="https://z1.ax1x.com/2023/11/01/piuKkSx.png">
</a>
<p class="img-desc" style="text-align: center">▲ kNN算法流程可视化。</p>
<ol>
<li>对未知类别的数据集中的每个点：
<ul>
<li>计算已知类别数据集众多点与当前点之间的距离；</li>
<li>按照距离递增次序排序。</li>
</ul>
</li>
<li>选取与当前点距离最小的k个点：
<ul>
<li>选定前k个点所在类别的出现频率</li>
<li>返回前k个点出现频率最高的类别作为当前点的预测分类</li>
</ul>
</li>
<li>重复步骤，完成对所有点的预测分类</li>
</ol>
<h3 id="python实现" class="headerLink">
    <a href="#python%e5%ae%9e%e7%8e%b0" class="header-mark"></a>Python实现</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">KNN</span><span class="p">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">X_train</span> <span class="o">=</span> <span class="n">X</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">y_train</span> <span class="o">=</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">euclidean_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">y_pred</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_predict</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y_pred</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">distances</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">euclidean_distance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x_train</span><span class="p">)</span> <span class="k">for</span> <span class="n">x_train</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_train</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">k_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">distances</span><span class="p">)[:</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">k_nearest_labels</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">y_train</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">k_indices</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">most_common</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">k_nearest_labels</span><span class="p">)</span><span class="o">.</span><span class="n">most_common</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">most_common</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"> <span class="n">一个简单的例子</span><span class="err">：</span>
</span></span><span class="line"><span class="cl"><span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
</span></span><span class="line"><span class="cl"><span class="n">y_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
</span></span><span class="line"><span class="cl"><span class="n">clf</span> <span class="o">=</span> <span class="n">KNN</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">predictions</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="改进" class="headerLink">
    <a href="#%e6%94%b9%e8%bf%9b" class="header-mark"></a>改进</h2><h3 id="主要挑战" class="headerLink">
    <a href="#%e4%b8%bb%e8%a6%81%e6%8c%91%e6%88%98" class="header-mark"></a>主要挑战</h3><ol>
<li>前置处理：特征的选择</li>
<li>模型
<ul>
<li>合适的度量函数</li>
<li>合适的K值</li>
<li>降低训练和预测的复杂度</li>
</ul>
</li>
</ol>
<h3 id="kd树" class="headerLink">
    <a href="#kd%e6%a0%91" class="header-mark"></a>kd树</h3><p>一种二叉树数据结构，用于优化搜索算法。</p>
<p><strong>优势：</strong></p>
<ol>
<li>降低搜索维度</li>
<li>提高搜索效率</li>
<li>更少的存储需求</li>
<li>支持范围搜索</li>
</ol>
<p>可能因数据的特定分布而表现不佳。<sup id="fnref:9"><a href="#fn:9" class="footnote-ref" role="doc-noteref">9</a></sup></p>
<h4 id="构造11" class="headerLink">
    <a href="#%e6%9e%84%e9%80%a011" class="header-mark"></a>构造<sup id="fnref:10"><a href="#fn:10" class="footnote-ref" role="doc-noteref">10</a></sup></h4><a class="lightgallery" href="https://z1.ax1x.com/2023/11/01/piuKif1.png" data-thumbnail="https://z1.ax1x.com/2023/11/01/piuKif1.png">
</a>
<p class="img-desc" style="text-align: center">▲ kd树的构造。</p>
<ol>
<li>构造根结点，使根结点对应于 k 维空间中包含所有实例点的超矩形区域。</li>
<li>递归（生成子结点）：
<ul>
<li>选择坐标轴和切分点，确定一个超平面</li>
<li>将当前超矩形区域切分为左右两个子区域</li>
<li>直到子区域内没有实例时终止。</li>
</ul>
</li>
<li>实例保存在相应的结点上。</li>
</ol>
<p><strong>如何选择：</strong></p>
<ul>
<li>空间切分参照：坐标轴</li>
<li>切分点的选择：中位数</li>
</ul>
<h4 id="搜索" class="headerLink">
    <a href="#%e6%90%9c%e7%b4%a2" class="header-mark"></a>搜索</h4><a class="lightgallery" href="https://z1.ax1x.com/2023/11/01/piuKAl6.png" data-thumbnail="https://z1.ax1x.com/2023/11/01/piuKAl6.png">
</a>
<p class="img-desc" style="text-align: center">▲ kd树的搜索。</p>
<h4 id="算法" class="headerLink">
    <a href="#%e7%ae%97%e6%b3%95" class="header-mark"></a>算法</h4><p>[输入] 已构造的 kd 树，目标点 x;</p>
<p>[输出] x 的 k 近邻。</p>
<ol>
<li>在 kd 树中找出包含目标点 x 的叶结点：从根结点出发，递归地向下访问 kd 树。若目标点 x 当前维的坐标小于切分点的坐标，则移动到左子结点，否则移动到右子结点，直到子结点为叶结点为止。</li>
<li>构建“当前 k 近邻点集”，将该叶结点插入“当前 k 近邻点集”，并计算该结点到目标点 x 的距离。</li>
<li>递归地向上回退，在每个结点进行以下操作:
<ul>
<li>如果“当前 k 近邻点集”的元素数量 &lt; k，则将该结点插入“当前 k 近邻点集”，并计算该结点到目标点 x 的距离;</li>
<li>如果“当前 k 近邻点集”的元素数量 = k，但该结点到目标点 x 的距离小于“当前 k 近邻点集”中最远 点到目标点 x 的距离，则将该结点插入“当前 k 近邻点集”，并删除原先的最远点。</li>
<li>检查另一子结点对应的区域是否与以目标点 x 为球心、以目标点 x 与“当前 k 近邻点集”中最远点的距离为半径的超球体相交。 如果相交，可能在另一个子结点对应的区域内存在距离目标点更近的点，移动到另一个子结点，接着，递归地进行 k 近邻搜索; 如果不相交，向上回退。</li>
</ul>
</li>
<li>当回退到根结点时，搜索结束(若此时“当前 k 近邻点集”中的元素不足 k 个，则需要访问另一半树的结点)。</li>
<li>最后的“当前 k 近邻点集”中的 k 个点即为 x 的 k 近邻点。</li>
</ol>
<h4 id="python实现-1" class="headerLink">
    <a href="#python%e5%ae%9e%e7%8e%b0-1" class="header-mark"></a>Python实现</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">data</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">KdTree</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">create_Tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="ow">not</span> <span class="n">dataset</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">        <span class="n">mid_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">        <span class="n">axis</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
</span></span><span class="line"><span class="cl">        <span class="n">sort_dataset</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">axis</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">        <span class="n">mid_data</span> <span class="o">=</span> <span class="n">sort_dataset</span><span class="p">[</span><span class="n">mid_index</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">cur_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">mid_data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">left_data</span> <span class="o">=</span> <span class="n">sort_dataset</span><span class="p">[:</span><span class="n">mid_index</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">right_data</span> <span class="o">=</span> <span class="n">sort_dataset</span><span class="p">[</span><span class="n">mid_index</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
</span></span><span class="line"><span class="cl">        <span class="n">cur_node</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_Tree</span><span class="p">(</span><span class="n">left_data</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">cur_node</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_Tree</span><span class="p">(</span><span class="n">right_data</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">cur_node</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">new_data</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">near_point</span> <span class="o">=</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">near_val</span> <span class="o">=</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span>
</span></span><span class="line"><span class="cl">            <span class="n">axis</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">new_data</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">near_val</span> <span class="ow">or</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">near_val</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="bp">self</span><span class="o">.</span><span class="n">near_val</span> <span class="o">=</span> <span class="n">dist</span>
</span></span><span class="line"><span class="cl">                <span class="bp">self</span><span class="o">.</span><span class="n">near_point</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">new_data</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">near_val</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">new_data</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">                <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">dfs</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">near_point</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point_1</span><span class="p">,</span> <span class="n">point_2</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">res</span> <span class="o">+=</span> <span class="p">(</span><span class="n">point_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">point_2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">res</span> <span class="o">**</span> <span class="mf">0.5</span>
</span></span><span class="line"><span class="cl"><span class="n">data_set</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">9</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
</span></span><span class="line"><span class="cl"><span class="n">new_data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_set</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="n">kd_tree</span> <span class="o">=</span> <span class="n">KdTree</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">our_tree</span> <span class="o">=</span> <span class="n">kd_tree</span><span class="o">.</span><span class="n">create_Tree</span><span class="p">(</span><span class="n">data_set</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">predict</span> <span class="o">=</span> <span class="n">kd_tree</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">our_tree</span><span class="p">,</span> <span class="n">new_data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">predict</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="马氏距离" class="headerLink">
    <a href="#%e9%a9%ac%e6%b0%8f%e8%b7%9d%e7%a6%bb" class="header-mark"></a>马氏距离</h3><p>由P.C. Mahalanobis提出；基于样本分布的一种距离测量。</p>
<ul>
<li>考虑特征之间的相关性</li>
<li>对数据的缩放不敏感</li>
<li>考虑协方差结构</li>
<li>适用于异常值和噪声数据<sup id="fnref:11"><a href="#fn:11" class="footnote-ref" role="doc-noteref">11</a></sup></li>
</ul>
<p>广泛用于分类和聚类分析。</p>
<p>s</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>垃圾邮件过滤：自动将电子邮件分为垃圾邮件和非垃圾邮件。<br>
医学诊断：基于患者的症状数据来诊断疾病或预测病人的疾病风险。<br>
金融风险评估：根据客户的财务和信用记录来评估客户的信用风险。<br>
情感分析：根据文本数据中的情感内容对文本进行情感分类，如积极、消极或中性。<br>
图像识别：对图像进行分类，例如识别数字、物体或人脸等。<br>
生物信息学：基因序列分类，如预测蛋白质功能或基因表达模式。<br>
客户分类：根据客户的行为和偏好将客户分成不同的市场细分。&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>KNN算法于1948年由Cover和Hart提出。<br>
存在一个样本数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每个数据与所属分类的对应关系。输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）的分类标签。一般来说，只选择样本数据集中前k个最相似的数据。k一般不大于20，最后，选择k个中出现次数最多的分类，作为新数据的分类。&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>数值型数据是指具有数量意义的数据，可以进行数学运算和比较。这种数据通常表示为数字，例如年龄、温度、身高等。在机器学习中，数值型数据常用于回归分析和连续变量的预测。标称型数据则是指无序分类的数据，其中每个值代表一个类别而没有数量意义。标称型数据通常表示为符号或字符串，例如血型、性别、品种等。在机器学习中，标称型数据通常用于分类问题，其中算法需要将输入数据映射到预定义的类别或标签。<br>
k最近邻算法 (kNN) 适用于处理这两种类型的数据。对于数值型数据，它可以基于数值之间的距离进行分类；对于标称型数据，它可以根据邻近样本的标签进行投票，并将测试样本分类为获得最多投票的类别。因此，kNN 算法对于这两种数据类型都有较好的适用性。<br>
还有其他类型：<br>
顺序型数据：顺序型数据是一种具有顺序或等级关系的数据类型，其中数据值之间存在某种顺序关系，但没有明确的数值差异。例如，学历等级（如小学、初中、高中、大学等）可以被视为顺序型数据。<br>
时间序列数据：时间序列数据是按照时间顺序排列的数据集合，通常是在一系列连续时间点上收集的数据。例如，股票价格、天气数据、经济指标等都属于时间序列数据。<br>
区间型数据：区间型数据是指数据值表示某个范围内的值，而不是特定的数值。这种数据类型通常用于表示测量的范围。例如，温度范围、年龄段等可以被视为区间型数据。<br>
比率型数据：比率型数据是具有固定比例关系的数据类型，其中数据之间存在明确的比率关系。比率型数据具有绝对零点，可以进行比较和数学运算。例如，长度、重量、时间间隔等都属于比率型数据。<br>
文本数据：文本数据是指以自然语言形式表示的数据，通常包含语句、段落或文档。处理文本数据通常需要使用自然语言处理技术来提取、转换和分析文本信息。&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p>老师反馈：这里的表述并不严谨，模型需要通过交叉验证来确认参数 k&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5">
<p>简单直观，非参数化：kNN 是一种非参数化方法，不对数据的分布做任何假设。因此，在处理复杂的数据集和未知的数据分布时，它通常具有很好的适应性。<br>
对异常值鲁棒：kNN 对异常值比较鲁棒，因为它基于周围数据点的多数投票来确定分类，可以减少异常值对结果的影响。<br>
适应多类别问题：kNN 能够很好地适应多类别分类问题，因为它可以通过投票的方式来确定一个实例所属的类别。<br>
但是对高维数据的处理效率较低，需要大量的存储空间和计算时间；在数据不平衡或噪声较多的情况下，它可能会产生较差的分类结果。&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6">
<p>计算成本高：kNN 算法需要计算每个测试点与所有训练点之间的距离，因此在处理大规模数据集时，计算成本会变得非常高。<br>
存储成本高：除了计算成本高外，kNN 算法还需要存储整个训练集，这对于大规模数据集来说会占用大量的存储空间。<br>
维度灾难：随着数据维度的增加，kNN 算法的性能可能会下降，因为在高维空间中，数据点之间的距离变得更加稀疏，导致算法的效率降低。<br>
数据不平衡问题：在处理数据不平衡或噪声较多的数据集时，kNN 算法可能会受到数据分布的影响，从而导致分类性能下降。&#160;<a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:7">
<p>近似误差是指模型用于近似真实关系的误差，通常表示模型与真实值之间的差异。<br>
估计误差是指使用样本数据估计整体数据集特征时产生的误差。在 kNN 中，估计误差通常与样本的选择和样本的分布有关。<br>
K值的减小：模型变得复杂，容易发生过拟合。相当于用较小的邻域中的训练实例进行预测，只有与输入实例较近的(相似的)训练实例才会对预测结果起作用，对噪声敏感，即预测结果会对近邻的实例点非常敏感。如果邻近的实例点恰巧是噪声，预测就会出错。换句话说，k 值的减小就意味着整体模型变得复杂，容易发生过拟合。<br>
K值的增大：就意味着整体的模型变得简单.产生更平滑的决策边界，但可能会忽略数据的局部特征。这时与输入实例较远的(不相似的)训练实例也会对预测起作用，使预测发生错误。k 值的增大就意味着整体的模型变得简单。<br>
k 值一般取一个比较小的数值。通常采用交叉验证法来选取最优的k 值。具体可以取部分训练集作为测试集，在不同取值条件下观察最优值。&#160;<a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:8">
<p>特征空间中两个实例点的距离是两个实例点相似程度的反映。k 近邻模型的特征空间一般是 n 维实数向量空间 $R^n$，使用的距离是欧氏距离，但也可以是其他距离，如更一般的 $L_p$ 距离或 Minkowski 距离。&#160;<a href="#fnref:8" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:9">
<p>实现 k 近邻法时，主要考虑的问题是如何对训练数据进行快速 k 近邻搜索。这点在特征空间的维数大及训练数据容量大时尤其必要。k 近邻法最简单的实现方法是线性扫描。这时要计算输入实例与每一个训练实例的距离。当训练集很大时，计算非常耗时，这种方法是不可行的。为了提高k 近邻搜索的效率，可以考虑使用特殊的结构存储训练数据，以减少计算距离的次数。具体方法很多，下面介绍其中的 kd 树方法。<br>
使用 kd 树相比直接计算方法的主要好处在于它可以有效地减少计算量。kd 树是一种二叉树数据结构，它可以用于优化搜索算法，特别是在高维空间中。<br>
以下是 kd 树相对于直接计算方法的一些优势：<br>
降低搜索维度：kd 树能够将搜索范围缩小到与搜索点最近的局部区域，从而避免不必要的计算。<br>
提高搜索效率：在具有大量数据点的高维空间中，kd 树可以更快地定位最近邻居，因为它可以避免对所有数据点进行逐一比较。<br>
更少的存储需求：相对于直接计算方法，kd 树通常需要更少的存储空间，因为它可以通过二叉树结构有效地组织数据。<br>
支持范围搜索：除了最近邻搜索之外，kd 树还可以很容易地扩展到支持范围搜索，以查找在给定半径内的所有邻居。<br>
尽管 kd 树具有这些优势，但它可能会因数据的特定分布而表现不佳。例如，在存在大量密集聚集数据点的区域，kd 树的性能可能会下降。因此，在实际应用中，应该根据数据集的特点选择合适的算法来进行近邻搜索。&#160;<a href="#fnref:9" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:10">
<p>kd 树是一种对 k 维空间中的实例点进行存储以便对其进行快速检索的树形数据结构。kd 树是二叉树，表示对 k 维空间的一个划分。构造 kd 树相当于不断地用垂直于坐标轴的超平面将k 维空间切分，构成一系列的飞 维超矩形区域。kd树的每个结点对应于一个k 维超矩形区域。<br>
构造 kd 树的方法如下:构造根结点，使根结点对应于 k 维空间中包含所有实例点的超矩形区域:通过下面的递归方法，不断地对 k 维空间进行切分，生成子结点。在超矩形区域(结点)上选择一个坐标轴和在此坐标轴上的一个切分点，确定一个超平面，这个超平面通过选定的切分点并垂直于选定的坐标轴，将当前超矩形区域切分为左右两个子区域（子结点）；这时，实例被分到两个子区域。这个过程直到子区域内没有实例时终止（终止时的结点为叶结点）。在此过程中，将实例保存在相应的结点上。<br>
平衡树：使用中位数作为划分点可以保证树的相对平衡，避免出现极端情况下的不平衡树结构，从而使得搜索效率总体比较高，但未必最优。考虑一些离群点。&#160;<a href="#fnref:10" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:11">
<p>考虑特征之间的相关性：马氏距离能够考虑数据特征之间的相关性，而欧氏距离只考虑各个维度之间的直线距离。这意味着马氏距离在具有相关特征的数据集上能够提供更加准确的距离度量。<br>
对数据的缩放不敏感：在某些情况下，数据的不同特征可能具有不同的度量单位或尺度。马氏距离能够对数据的缩放不敏感，因此可以更好地处理这种情况，而欧氏距离可能受到数据尺度的影响。<br>
考虑协方差结构：马氏距离考虑了数据的协方差结构，因此可以更好地捕捉数据特征之间的线性关系。这使得马氏距离在处理多元正态分布数据时能够提供更加准确的距离度量。<br>
适用于异常值和噪声数据：马氏距离能够对异常值和噪声数据具有更好的鲁棒性，因为它考虑了数据的协方差结构，可以减少这些异常值对距离度量的影响。&#160;<a href="#fnref:11" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>]]></description>
</item><item>
    <title>SQL 技术栈基本语法</title>
    <link>https://blog.ralvines.top/sql/</link>
    <pubDate>Sun, 22 Oct 2023 20:20:40 &#43;0800</pubDate><author>
                        <name>Ralvine</name><uri>https://blog.ralvines.top/about/praise/</uri><email>ralvine@163.com</email></author><guid>https://blog.ralvines.top/sql/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://z1.ax1x.com/2023/10/23/piAtBlV.png" referrerpolicy="no-referrer">
            </div><h2 id="sql语法12" class="headerLink">
    <a href="#sql%e8%af%ad%e6%b3%9512" class="header-mark"></a>SQL语法<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup><sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></h2><h3 id="查询" class="headerLink">
    <a href="#%e6%9f%a5%e8%af%a2" class="header-mark"></a>查询</h3><ul>
<li>语法 select-from-where-group by-having-order by-limit</li>
<li>运行 from-where-group by-having-order by-limit-select</li>
</ul>
<h4 id="基础语句" class="headerLink">
    <a href="#%e5%9f%ba%e7%a1%80%e8%af%ad%e5%8f%a5" class="header-mark"></a>基础语句</h4><ol>
<li>select &amp; from</li>
</ol>
<ul>
<li><code>select 字段（展示） from 表（数据来源）</code></li>
<li><code>*</code> 所有列</li>
<li><code>as</code> 别名</li>
<li><code>distinct</code> 去重，必须置首</li>
<li>计算（必须包含被引用的字段，除非可以独立计算）</li>
<li><code>select gdp, distinct population, gdp/population as averGDP from world</code></li>
</ul>
<ol start="2">
<li>where</li>
</ol>
<ul>
<li>筛选行数据</li>
<li><code>where 字段名 运算符 值</code></li>
<li>比较符 <code>=, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;, !=</code></li>
<li>条件范围 <code>in (...), not in, between and（闭区间）, is null, is not null</code></li>
<li>逻辑 <code>and, or, not</code></li>
<li>模糊查询 <code>like 通配符 字符</code>，通配符 <code>%, _</code> 匹配单个或多个字符</li>
<li><code>where population &gt;= 20, name in ('Germany', 'Norway')</code></li>
</ul>
<ol start="3">
<li>order by</li>
</ol>
<ul>
<li>规定结果集显示顺序</li>
<li><code>asc, desc</code> 默认升序</li>
<li>主字段</li>
<li>将某些排最后 <code>order by subject in ('chem','phys'), subject</code></li>
</ul>
<ol start="4">
<li>limit</li>
</ol>
<ul>
<li><code>limit [位置偏移量,] 行数</code></li>
<li>返回排名第4-7的数据 <code>order by area desc limit 3,4</code></li>
</ul>
<ol start="5">
<li>group by</li>
</ol>
<ul>
<li><code>group by 字段名</code></li>
<li>直接使用只取对应组的第一个</li>
<li>和聚合函数连用 <code>AVG(), COUNT(), MAX(), MIN(), SUM()</code>，计算组内结果</li>
<li>和where的区别：可以对各组进行单独求解</li>
<li>查询nobel表中2013-2015每年每科目获奖人数，按各年人数降序</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="n">yr</span><span class="p">,</span><span class="w"> </span><span class="n">subject</span><span class="p">,</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">winner</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">from</span><span class="w"> </span><span class="n">nobel</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">where</span><span class="w"> </span><span class="n">yr</span><span class="w"> </span><span class="k">between</span><span class="w"> </span><span class="mi">2013</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="mi">2015</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">group</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">yr</span><span class="p">,</span><span class="w"> </span><span class="n">subject</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">order</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">yr</span><span class="w"> </span><span class="k">desc</span><span class="p">,</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">winner</span><span class="p">)</span><span class="w"> </span><span class="k">desc</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="6">
<li>having</li>
</ol>
<ul>
<li>对分组后数据进行筛选</li>
</ul>
<h4 id="主要函数" class="headerLink">
    <a href="#%e4%b8%bb%e8%a6%81%e5%87%bd%e6%95%b0" class="header-mark"></a>主要函数</h4><ol>
<li><code>round(x,y)</code></li>
</ol>
<ul>
<li>四舍五入精确到小数点后y位，y负数仅保留</li>
<li><code>round(14.15,-1)=10</code></li>
</ul>
<ol start="2">
<li><code>concat(s1,s2,...)</code></li>
</ol>
<ul>
<li>连接字符串</li>
<li><code>concat('My',null,'SQL')=null</code></li>
</ul>
<ol start="3">
<li><code>replace(s,s1,s2)</code></li>
</ol>
<ul>
<li>用s2替换s中所有s1</li>
</ul>
<ol start="4">
<li><code>left(s,n), right(s,n), substring(s,n,len)</code></li>
</ol>
<ul>
<li>返回左边或右边n个字符</li>
<li>返回第n个起（负数则从右起）长度为len的子字符串，无len取到底</li>
</ul>
<ol start="5">
<li><code>cast(x as type)</code></li>
</ol>
<ul>
<li><code>char(n), date, time, datetime, decimal</code></li>
</ul>
<ol start="6">
<li><code>year(date), month(date), day(date)</code></li>
</ol>
<ul>
<li><code>month(2021-08-21)=8</code></li>
</ul>
<ol start="7">
<li><code>date_add(date,interval expr type), date_sub(...)</code></li>
</ol>
<ul>
<li>type: <code>second, minute, hour, day, week, month, quarter, year</code></li>
<li><code>date_sub('2021-08-03 23:59:59',interval 2 month)=2021-06-03 23:59:59</code></li>
</ul>
<ol start="8">
<li><code>datediff(date1,date2)</code></li>
</ol>
<ul>
<li>计算间隔天数</li>
</ul>
<ol start="9">
<li><code>date_format(date,format)</code></li>
</ol>
<ul>
<li>format 参见<a href="https://www.w3school.com.cn/sql/func_date_format.asp" target="_blank" rel="noopener noreferrer">此表</a></li>
</ul>
<ol start="10">
<li><code>if(expr,v1,v2)</code></li>
</ol>
<ul>
<li><code>if(1&lt;2,'Y','N')=Y</code></li>
</ul>
<ol start="11">
<li><code>case expr when v1 then r1[when v2 then r2] ... [else rn] end</code></li>
</ol>
<h4 id="高级语句" class="headerLink">
    <a href="#%e9%ab%98%e7%ba%a7%e8%af%ad%e5%8f%a5" class="header-mark"></a>高级语句</h4><ol>
<li>窗口函数</li>
</ol>
<ul>
<li><code>over([partition by 字段][order by 字段 asc/desc])</code></li>
<li>排序窗口 <code>rank()over(), dense_rank()over(), row_number()over()</code></li>
<li>偏移分析 <code>lag(字段名,偏移量[,默认值])over(), lead(字段名,偏移量[,默认值])over()</code> 往上/往下</li>
</ul>
<p><strong>例题</strong></p>
<ul>
<li>对每年票数从高到低赋予名次 <code>rank()over(partition by yr order by votes desc) as posn</code></li>
<li><a href="https://sglzoo.net/wiki/Window_LAG" target="_blank" rel="noopener noreferrer"><strong>covid每天新增人数</strong></a></li>
</ul>
<ol start="2">
<li>表连接</li>
</ol>
<ul>
<li><code>from 表1 inner/left/right join 表2 on 表1.字段 = 表2.字段</code></li>
<li>内连接会筛掉没有连上的行</li>
<li>左/右连接保留对应 (from) 表内所有数据</li>
<li>重名时指定字段列所在表 <code>select game.id</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="k">distinct</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">from</span><span class="w"> </span><span class="n">teacher</span><span class="w"> </span><span class="n">t</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">left</span><span class="w"> </span><span class="k">join</span><span class="w"> </span><span class="n">dept</span><span class="w"> </span><span class="n">d</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">on</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">dept</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>子查询</li>
</ol>
<ul>
<li><code>()</code> 多层嵌套</li>
<li>一般用于<code>from, where</code></li>
</ul>
<ol start="4">
<li>组合查询</li>
</ol>
<ul>
<li>union 分隔两条或以上的<code>select</code>语句</li>
<li>规则：每个查询必须包含相同列、表达式或聚集函数</li>
<li>场景：对一张表执行多个查询并按一个查询返回数据，或在一个查询中从不同表返回数据</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="k">column_name</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">table1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">union</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="k">column_name</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">table2</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>union all</code> 允许重复数据</li>
</ul>
<h4 id="实例" class="headerLink">
    <a href="#%e5%ae%9e%e4%be%8b" class="header-mark"></a>实例</h4><h3 id="操作" class="headerLink">
    <a href="#%e6%93%8d%e4%bd%9c" class="header-mark"></a>操作</h3><h4 id="表" class="headerLink">
    <a href="#%e8%a1%a8" class="header-mark"></a>表</h4><ol>
<li>创建</li>
</ol>
<ul>
<li><code>create table 表名 (字段名 字段类型 约束)</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">create</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">student</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="n">id</span><span class="w"> </span><span class="nb">integer</span><span class="w"> </span><span class="k">primary</span><span class="w"> </span><span class="k">key</span><span class="w"> </span><span class="n">autoincrement</span><span class="p">,</span><span class="w"> </span><span class="c1">--主键自增长
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">	</span><span class="n">name</span><span class="w"> </span><span class="nb">text</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">null</span><span class="p">,</span><span class="w"> </span><span class="c1">--非空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">	</span><span class="n">age</span><span class="w"> </span><span class="nb">integer</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="n">email</span><span class="w"> </span><span class="nb">text</span><span class="w"> </span><span class="k">unique</span><span class="p">,</span><span class="w"> </span><span class="c1">--唯一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">	</span><span class="k">check</span><span class="w"> </span><span class="p">(</span><span class="n">age</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>参见Access, Server, MySQL各自数据类型规范。</li>
<li>约束
<ul>
<li>主键 <code>primary key</code> 非空唯一</li>
<li>非空 <code>no null</code></li>
<li>唯一 <code>unique</code></li>
<li>主键自增长（int时） <code>autoincrement</code></li>
<li>外键 <code>foreign key</code> 关联外表主键</li>
<li><code>check</code> 限制列值范围</li>
<li><code>default 默认值</code></li>
</ul>
</li>
</ul>
<ol start="2">
<li>更新
<code>alter table 表名 [操作]</code></li>
</ol>
<ul>
<li><code>add 列名 类型</code></li>
<li><code>drop column 列名</code></li>
<li><code>modify 列名 类型</code> 修改列类型</li>
<li><code>chanage 列名 新列名 类型</code> 修改列名</li>
<li><code>rename to 表名</code> 修改表名</li>
</ul>
<ol start="3">
<li>查询</li>
</ol>
<ul>
<li><code>show tables</code> 当前数据库下所有表名称</li>
<li><code>desc 表名</code> 查询表详细信息</li>
</ul>
<ol start="4">
<li>删除</li>
</ol>
<ul>
<li><code>drop table</code></li>
</ul>
<h4 id="数据" class="headerLink">
    <a href="#%e6%95%b0%e6%8d%ae" class="header-mark"></a>数据</h4><ol>
<li>增</li>
</ol>
<ul>
<li><code>insert into 表(列1,列2,...) values(值1,值2,...)</code></li>
<li>省略列名给所有列添加数据</li>
<li><code>insert into student(id,name,age) values(3,'guy',16)</code></li>
</ul>
<ol start="2">
<li>删</li>
</ol>
<ul>
<li><code>delete from 表 [where 条件]</code></li>
<li>不加条件则删除表中所有数据</li>
</ul>
<ol start="3">
<li>改</li>
</ol>
<ul>
<li><code>update 表 set 列1=值1, 列2=值2, ... [where 条件]</code></li>
<li><code>update scores set scores=scores+5 where scores&lt;=95</code></li>
</ul>
<h3 id="事务" class="headerLink">
    <a href="#%e4%ba%8b%e5%8a%a1" class="header-mark"></a>事务</h3><ol>
<li>SQL操作批处理：全部执行或不执行</li>
<li>分类</li>
</ol>
<ul>
<li>显式：用<code>begin transaction</code>指定</li>
<li>隐式</li>
<li>自动提交</li>
</ul>
<ol start="3">
<li>使用</li>
</ol>
<ul>
<li><code>begin</code> 设置起点</li>
<li><code>commit</code> 永久化</li>
<li><code>rollback</code> 遗忘</li>
<li><code>save</code> 特定标记 部分回滚</li>
</ul>
<ol start="4">
<li>判断</li>
</ol>
<h3 id="索引与视图7" class="headerLink">
    <a href="#%e7%b4%a2%e5%bc%95%e4%b8%8e%e8%a7%86%e5%9b%be7" class="header-mark"></a>索引与视图<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup></h3><h3 id="触发器" class="headerLink">
    <a href="#%e8%a7%a6%e5%8f%91%e5%99%a8" class="header-mark"></a>触发器</h3><h2 id="hive-sql5" class="headerLink">
    <a href="#hive-sql5" class="header-mark"></a>Hive SQL<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup></h2><h3 id="ddl" class="headerLink">
    <a href="#ddl" class="header-mark"></a>DDL</h3><ul>
<li>数据定义语句</li>
</ul>
<ol>
<li>库操作</li>
<li>表操作</li>
</ol>
<h2 id="spark-sql3" class="headerLink">
    <a href="#spark-sql3" class="header-mark"></a>Spark SQL<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup></h2><h2 id="pyspark4" class="headerLink">
    <a href="#pyspark4" class="header-mark"></a>PySpark<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup></h2><h3 id="常见问题6" class="headerLink">
    <a href="#%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%986" class="header-mark"></a>常见问题<sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup></h3><div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>SQL从入门到实战 @戴师兄 <a href="https://yrzu9y4st8.feishu.cn/mindnotes/bmncn7s9I4IyCLgrrQCskdP7dRf" target="_blank" rel="noopener noreferrer">https://yrzu9y4st8.feishu.cn/mindnotes/bmncn7s9I4IyCLgrrQCskdP7dRf</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>数据库（SQL）面试题，基础知识（超全面） @weihubeats <a href="https://blog.csdn.net/qq_42651904/article/details/83146345" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qq_42651904/article/details/83146345</a>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>数据分析师之——我的SQL自学之路 @意识成长 <a href="https://zhuanlan.zhihu.com/p/220172077" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/220172077</a> <figure><a class="lightgallery" href="https://pic3.zhimg.com/v2-1ac8dc043d5fc80916ddea5d6d97e376_r.jpg" title="MySQL大纲" data-thumbnail="https://pic3.zhimg.com/v2-1ac8dc043d5fc80916ddea5d6d97e376_r.jpg">
        
    </a></figure>&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p>一文学完所有的Hive Sql（两万字最全详解） @五分钟学大数据 <a href="https://blog.csdn.net/helloHbulie/article/details/115376657" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/helloHbulie/article/details/115376657</a>&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5">
<p>Spark SQL从入门到精通 @浪尖 <a href="https://zhuanlan.zhihu.com/p/45729547" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/45729547</a>&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6">
<p>3万字长文 PySpark入门级学习教程，框架思维 @小晨说数据 <a href="https://zhuanlan.zhihu.com/p/395431025" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/395431025</a>&#160;<a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:7">
<p>SQL经典50题&amp;答案 @胖熊酱 <a href="https://zhuanlan.zhihu.com/p/67645448" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/67645448</a>&#160;<a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>]]></description>
</item><item>
    <title>大数据基本理论</title>
    <link>https://blog.ralvines.top/big-data/</link>
    <pubDate>Sun, 22 Oct 2023 20:20:40 &#43;0800</pubDate><author>
                        <name>Ralvine</name><uri>https://blog.ralvines.top/about/praise/</uri><email>ralvine@163.com</email></author><guid>https://blog.ralvines.top/big-data/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://z1.ax1x.com/2023/10/23/piApGh6.jpg" referrerpolicy="no-referrer">
            </div><h2 id="大数据概念1" class="headerLink">
    <a href="#%e5%a4%a7%e6%95%b0%e6%8d%ae%e6%a6%82%e5%bf%b51" class="header-mark"></a>大数据概念<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></h2><h3 id="定义" class="headerLink">
    <a href="#%e5%ae%9a%e4%b9%89" class="header-mark"></a>定义</h3><p>数据量特别大、数据类别特别复杂的数据集，无法用传统的数据库进行存储，管理和处理。</p>
<h3 id="特点" class="headerLink">
    <a href="#%e7%89%b9%e7%82%b9" class="header-mark"></a>特点</h3><p><strong>4V</strong></p>
<ul>
<li>数据量大（Volume）：PB级别</li>
<li>类别复杂（Variety）：结构化（数字、符号等），非结构化（文本、图像、声音等）</li>
<li>处理速度快（Velocity）</li>
<li>真实性高（Veracity）</li>
</ul>
<p>且价值密度很低，质量差别大，可以产生价值。</p>
<h3 id="示例2" class="headerLink">
    <a href="#%e7%a4%ba%e4%be%8b2" class="header-mark"></a>示例<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></h3><p>超市：通过进销存数据+客户购物数据+社交网络舆情监测数据，预测接下来几天的销售预期，进而制定合适的营销策略增加销售。从而产生价值。</p>
<h3 id="作用" class="headerLink">
    <a href="#%e4%bd%9c%e7%94%a8" class="header-mark"></a>作用</h3><p>提炼出有用的数据。</p>
<h3 id="总体架构" class="headerLink">
    <a href="#%e6%80%bb%e4%bd%93%e6%9e%b6%e6%9e%84" class="header-mark"></a>总体架构</h3><ol>
<li>数据存储：解决类型复杂和数据量庞大的问题。</li>
<li>数据处理：快速和时效性。</li>
<li><strong>数据分析</strong>：价值筛选。</li>
</ol>
<p><strong>流程</strong>：保存于存储层，根据需求目标建立数据模型和分析指标，通过处理层的强大并行和分布式计算实现价值的生成。</p>
<h3 id="大数据分析" class="headerLink">
    <a href="#%e5%a4%a7%e6%95%b0%e6%8d%ae%e5%88%86%e6%9e%90" class="header-mark"></a>大数据分析</h3><ol>
<li>可视化。</li>
<li>数据挖掘：用算法提炼有价值信息。</li>
<li>预测：建立模型，预测趋势。</li>
<li>语义引擎：机器学习的成果，自主迭代，理解数据的含义。</li>
<li>质量管理：剔除错误数据。</li>
</ol>
<p><strong>流程</strong></p>
<ol>
<li>获取数据。</li>
<li>准备数据：数据探索、预处理。</li>
<li>分析数据：建立模型。</li>
<li>展示结果：可视化数据结论。</li>
<li>应用结论。</li>
</ol>
<h3 id="技术基础" class="headerLink">
    <a href="#%e6%8a%80%e6%9c%af%e5%9f%ba%e7%a1%80" class="header-mark"></a>技术基础</h3><p><strong>方向</strong></p>
<ol>
<li>集中式</li>
<li>分布式（前沿）</li>
</ol>
<p><strong>分布式文件系统优势</strong></p>
<ol>
<li>可扩展</li>
<li>容错</li>
<li>高并发：并行处理</li>
</ol>
<p><strong>突破</strong>：Google 分布式计算模型</p>
<ul>
<li>MapReduce：计算框架</li>
<li>GFS（Google File System）：文件系统</li>
<li>BigTable：数据存储系统</li>
</ul>
<p><strong>主流</strong></p>
<ol>
<li><strong>Hadoop</strong>：开源，标准
MapReduce分布式计算框架；
基于GFS的<strong>HDFS</strong>分布式文件系统；
基于BigTable的<strong>HBase</strong>数据存储系统。</li>
<li>Spark：基于Hadoop的改良
存储数据由硬盘改为内存，提高速度，短期处理。</li>
<li>Storm：Twitter主推
支持实时运算，不收集、存储数据，实时接收并处理、返回。</li>
</ol>
<p><strong>使用场景</strong></p>
<ol>
<li>Hadoop：离线、复杂</li>
<li>Spark：离线、快速</li>
<li>Storm：在线、实时</li>
</ol>
<h3 id="云计算" class="headerLink">
    <a href="#%e4%ba%91%e8%ae%a1%e7%ae%97" class="header-mark"></a>云计算</h3><p>降低大数据处理成本，提供基础。</p>
<h3 id="数据科学" class="headerLink">
    <a href="#%e6%95%b0%e6%8d%ae%e7%a7%91%e5%ad%a6" class="header-mark"></a>数据科学</h3><p>如何利用大数据产生价值。</p>
<p><strong>5P</strong></p>
<ul>
<li>目标：解决实际问题</li>
<li>人物：数据科学家</li>
<li>过程：团队沟通、技术工作</li>
<li>平台：计算、存储</li>
<li>可编程：R, Patterns 等</li>
</ul>
<h4 id="web应用" class="headerLink">
    <a href="#web%e5%ba%94%e7%94%a8" class="header-mark"></a>Web应用</h4><p>应用层：仍保持传统Web应用（LAMP、JavaEE、NODE等）。
数据存储：对日志等非结构数据使用分布式文件系统。</p>
<h2 id="数据治理3" class="headerLink">
    <a href="#%e6%95%b0%e6%8d%ae%e6%b2%bb%e7%90%863" class="header-mark"></a>数据治理<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup></h2><p>数据治理的最终目标是提升数据的价值。</p>
<h3 id="数据" class="headerLink">
    <a href="#%e6%95%b0%e6%8d%ae" class="header-mark"></a>数据</h3><p>指标 = 数字 + 解释</p>
<h3 id="治理" class="headerLink">
    <a href="#%e6%b2%bb%e7%90%86" class="header-mark"></a>治理</h3><p>管理共同事务的方法综合，实现利益调和与联合行动的过程。</p>
<p><strong>基本职能</strong></p>
<ul>
<li>计划：决策与机制建构。</li>
<li>组织：分配任务。</li>
<li>领导：激励、沟通、解决。</li>
<li>控制：监督、目标导向。</li>
</ul>
<h3 id="流程" class="headerLink">
    <a href="#%e6%b5%81%e7%a8%8b" class="header-mark"></a>流程</h3><ol>
<li>采集 存储</li>
<li>标准化 建模</li>
<li>清洗 质量控制</li>
<li>分析 交付需求 服务</li>
</ol>
<p><strong>示例</strong></p>
<ul>
<li>网易数据中台产品（网易数帆链接）</li>
<li>华为数据治理产品（数据湖治理）</li>
</ul>
<h3 id="工具" class="headerLink">
    <a href="#%e5%b7%a5%e5%85%b7" class="header-mark"></a>工具</h3><p><figure><a class="lightgallery" href="https://pic4.zhimg.com/80/v2-5102010cb038e90a7b86f308b78ddb7b_1440w.webp" title="数据治理的工具结构" data-thumbnail="https://pic4.zhimg.com/80/v2-5102010cb038e90a7b86f308b78ddb7b_1440w.webp">
        
    </a></figure></p>
<p class="img-desc">▲ 数据治理的工具结构</p>
<p><strong>基础支撑</strong>：同步和存储</p>
<ol>
<li>容器：提供治理动作的空间。</li>
<li>管道：提供数据传输的通道。</li>
</ol>
<p><strong>核心能力</strong>：标准化管理、建模开发、共享、安全。</p>
<p><strong>应用</strong>：展示（可视化）、算法（预测）。</p>
<h2 id="数据仓库4" class="headerLink">
    <a href="#%e6%95%b0%e6%8d%ae%e4%bb%93%e5%ba%934" class="header-mark"></a>数据仓库<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup></h2><h3 id="诞生" class="headerLink">
    <a href="#%e8%af%9e%e7%94%9f" class="header-mark"></a>诞生</h3><ol>
<li>历史积存：使用频率低，堆积导致查询性能下降。</li>
<li>企业分析：各部门数据抽取系统独立，数据不一致，资源浪费，权限存在风险。</li>
</ol>
<h3 id="概念" class="headerLink">
    <a href="#%e6%a6%82%e5%bf%b5" class="header-mark"></a>概念</h3><ul>
<li>Data Warehouse</li>
<li>目的：企业分析性报告和决策支持。</li>
<li>能力：业务数据筛选整合，BI（商业智能），支持到前端的可视化分析。</li>
<li>输入：各类数据源。</li>
<li>输出应用：分析、挖掘、报表。</li>
</ul>
<h3 id="特征" class="headerLink">
    <a href="#%e7%89%b9%e5%be%81" class="header-mark"></a>特征</h3><ol>
<li>主题：数据库对应项目，数据仓库基于实际需求，高度抽象整合，围绕主题组织。</li>
<li>集成：多个数据源的集成，存储方式各不相同，带有抽取、清洗、转换的过程。</li>
<li>稳定：保存历史快照，不允许修改，大多仅查询分析。</li>
<li>时变：定期接收新集成数据。以时间戳标记版本标记最新数据，老旧可定期删除。</li>
</ol>
<h3 id="结构" class="headerLink">
    <a href="#%e7%bb%93%e6%9e%84" class="header-mark"></a>结构</h3><p><figure><a class="lightgallery" href="https://pic3.zhimg.com/80/v2-9a8b8352571c3e7d18c031f8c5d8caee_1440w.webp" title="数据仓库的分层架构" data-thumbnail="https://pic3.zhimg.com/80/v2-9a8b8352571c3e7d18c031f8c5d8caee_1440w.webp">
        
    </a></figure></p>
<p class="img-desc">▲ 数据仓库的分层架构</p>
<p>ODS $\rightarrow$ DW $\rightarrow$ DA</p>
<ul>
<li>源数据：短周期、操作性，历史数据只读。</li>
<li>仓库：归宿，长期保存。</li>
<li>应用：从仓库独立出来面向主体需求所计算生成。</li>
</ul>
<h3 id="与数据库" class="headerLink">
    <a href="#%e4%b8%8e%e6%95%b0%e6%8d%ae%e5%ba%93" class="header-mark"></a>与数据库</h3><ul>
<li>数据库：面向交易，操作型，OLTP（On-Line Transaction Processing）。</li>
<li>数仓：历史数据分析，管理决策， OLAP（On-Line Analytical Processing）。</li>
</ul>
<p><strong>区别</strong></p>
<ol>
<li>/业务</li>
<li>存储历史/业务实时数据</li>
<li>引入冗余，多维度/避免冗余，易用</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>数据仓库</th>
<th>数据库</th>
</tr>
</thead>
<tbody>
<tr>
<td>面向</td>
<td>主题</td>
<td>业务</td>
</tr>
<tr>
<td>存储</td>
<td>历史</td>
<td>业务</td>
</tr>
<tr>
<td>类型</td>
<td>清洗过、综合</td>
<td>细节</td>
</tr>
<tr>
<td>冗余</td>
<td>有意引入，多维度指标分析</td>
<td>避免，易操作</td>
</tr>
<tr>
<td>设计</td>
<td>分析</td>
<td>捕获并调用</td>
</tr>
</tbody>
</table>
<p><strong>例子</strong>：银行数据库作为事务系统记账，数据仓库作为决策的平台分析数据。</p>
<h2 id="技术栈5" class="headerLink">
    <a href="#%e6%8a%80%e6%9c%af%e6%a0%885" class="header-mark"></a>技术栈<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup></h2><p><figure><a class="lightgallery" href="http://dbaplus.cn/uploadfile/2018/0508/20180508060539882.jpg" title="大数据技术栈" data-thumbnail="http://dbaplus.cn/uploadfile/2018/0508/20180508060539882.jpg">
        
    </a></figure></p>
<p class="img-desc">▲ 大数据技术栈</p>
<h3 id="采集与预处理" class="headerLink">
    <a href="#%e9%87%87%e9%9b%86%e4%b8%8e%e9%a2%84%e5%a4%84%e7%90%86" class="header-mark"></a>采集与预处理</h3><ul>
<li>Flume NG：实时日志收集系统。</li>
<li>Logstash：开源服务器端数据处理管道。</li>
<li>Sqoop：将数据在关系型数据库和Hadoop之间转移。</li>
<li>流式计算：对高吞吐量数据源的实时清洗、聚合与分析。
Strom：单主节点（nimbus）和多工作节点（supervisor）组成的主从结构
Spark Streaming</li>
<li>Kafka：分布式的、基于发布/订阅的消息系统。</li>
<li>Zookeeper：分布式的、开源的分布式应用程序协调服务，提供数据同步服务。</li>
</ul>
<h3 id="分布式存储" class="headerLink">
    <a href="#%e5%88%86%e5%b8%83%e5%bc%8f%e5%ad%98%e5%82%a8" class="header-mark"></a>分布式存储</h3><ul>
<li>HDFS，HBase</li>
<li>Redis：速度非常快的非关系数据库。</li>
</ul>
<h3 id="数据清洗" class="headerLink">
    <a href="#%e6%95%b0%e6%8d%ae%e6%b8%85%e6%b4%97" class="header-mark"></a>数据清洗</h3><ul>
<li>MapReduce：查询引擎，大规模数据集的并行计算。</li>
</ul>
<h3 id="查询与分析" class="headerLink">
    <a href="#%e6%9f%a5%e8%af%a2%e4%b8%8e%e5%88%86%e6%9e%90" class="header-mark"></a>查询与分析</h3><ul>
<li>Hive：客户端工具，把SQL语句翻译成MapReduce程序，结构化数据映射为数据库表，且有HQL查询功能，依赖HDFS和MapReduce。解决传统关系型数据库(MySql、Oracle)在大数据处理上的瓶颈。</li>
<li>Impala：Hive的补充，高效SQL查询。</li>
</ul>
<h3 id="可视化" class="headerLink">
    <a href="#%e5%8f%af%e8%a7%86%e5%8c%96" class="header-mark"></a>可视化</h3><p><strong>BI</strong>平台</p>
<ul>
<li>PowerBI</li>
<li>FineBI</li>
<li>Tableau</li>
<li>Oracle</li>
</ul>
<h3 id="全貌" class="headerLink">
    <a href="#%e5%85%a8%e8%b2%8c" class="header-mark"></a>全貌</h3><ul>
<li>采集和预处理</li>
<li>数据存储</li>
<li>数据库操作</li>
<li>数据仓库</li>
<li>机器学习</li>
<li>并行计算</li>
<li>可视化</li>
</ul>
<h2 id="数据分析理论业务层" class="headerLink">
    <a href="#%e6%95%b0%e6%8d%ae%e5%88%86%e6%9e%90%e7%90%86%e8%ae%ba%e4%b8%9a%e5%8a%a1%e5%b1%82" class="header-mark"></a>数据分析理论（业务层）</h2><ol>
<li>观测</li>
</ol>
<ul>
<li>获得数据：测量、爬取、现实场景的抽象与量化。</li>
<li>制作报表、图表。</li>
</ul>
<ol start="2">
<li>实验</li>
</ol>
<ul>
<li>提出假设或模型，并验证，解决实际问题。</li>
<li>例如A/B测试。</li>
</ul>
<ol start="3">
<li>应用</li>
</ol>
<ul>
<li>创造商业价值。</li>
</ul>
<h3 id="采集" class="headerLink">
    <a href="#%e9%87%87%e9%9b%86" class="header-mark"></a>采集</h3><ol>
<li>系统日志：埋点获取新数据。</li>
<li>传感器。</li>
<li>主动爬取和检索收集。</li>
<li>API获取对象提供的数据。</li>
</ol>
<h3 id="存储" class="headerLink">
    <a href="#%e5%ad%98%e5%82%a8" class="header-mark"></a>存储</h3><p><strong>数据库</strong>种类</p>
<ul>
<li>HiveSQL</li>
<li>MySQL</li>
<li>SQLserver</li>
</ul>
<h3 id="测量" class="headerLink">
    <a href="#%e6%b5%8b%e9%87%8f" class="header-mark"></a>测量</h3><p><strong>场景</strong></p>
<ol>
<li>日常维护：发现异常。</li>
<li>研究数据关系。</li>
</ol>
<p><strong>流程</strong></p>
<ol>
<li>设定标准：判断数据正常与否。</li>
<li>寻找原因。</li>
<li>计算推导相关性。</li>
</ol>
<h3 id="实验" class="headerLink">
    <a href="#%e5%ae%9e%e9%aa%8c" class="header-mark"></a>实验</h3><p>即用数据分析来检验某种假设或求解某个状态或预测指标。</p>
<p>严谨性：重复实验和控制变量。</p>
<h3 id="业务应用" class="headerLink">
    <a href="#%e4%b8%9a%e5%8a%a1%e5%ba%94%e7%94%a8" class="header-mark"></a>业务应用</h3><ol>
<li>明确目标，拆解指标</li>
</ol>
<ul>
<li>法则：MECE（Mutually Exclusive Collectively Exhaustive）即无重复无遗漏</li>
<li>方法：
<ul>
<li>流程拆解：按照时间流程顺序，如用户购买商品的全流程，漏斗分析法。</li>
<li>二分拆解：变量属性分两类，如白天/黑夜。</li>
<li>象限拆解：横纵坐标二维拆解。</li>
<li>杜邦分析：ROE（净资产收益率）=销售净利率<em>资产周转率</em>权益乘数。</li>
</ul>
</li>
<li>模型：
<ul>
<li>AARRR（Acquisition、Activation、Retention、Revenue、Refer）用户增长（获取、激活、存留、收益、推荐传播）。</li>
<li>PEST：政治（Politics）、经济（Economic）、社会（Society）、技术（Technology）。</li>
<li>RFM：根据客户活跃程度和交易金额贡献，进行客户价值细分。（近度-交易间隔，频度-交易次数，额度-金额）。</li>
<li>SWOT：企业优势（strength）、劣势（weakness）、机会（opportunity）和威胁（threats）。</li>
<li>5W1H：Who确定主题，Where进行数据集成，When时间段，What分析方法，Why原因，How (如何呈现结果）</li>
</ul>
</li>
</ul>
<ol start="2">
<li>准备相关数据：数据库取数，BI搭建看板。</li>
<li>观测：发现问题；实验：验证假设。</li>
<li>制定策略，迭代。</li>
</ol>
<p>自动化：使用算法针对业务目标自动监测和优化。</p>
<h2 id="数据预处理" class="headerLink">
    <a href="#%e6%95%b0%e6%8d%ae%e9%a2%84%e5%a4%84%e7%90%86" class="header-mark"></a>数据预处理</h2><h3 id="缺失值6" class="headerLink">
    <a href="#%e7%bc%ba%e5%a4%b1%e5%80%bc6" class="header-mark"></a>缺失值<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup></h3><ol>
<li>直接删除指标：若缺失太多，直接删除指标，该变量作废；如果本身数据源数量很大，或缺失较少，且剔除缺失指标后，剩余数据的其他变量指标仍然在问题域内有效，也可保留该变量。</li>
<li>替换类似值</li>
</ol>
<ul>
<li>定量数据，均值</li>
<li>定性数据，众数（出现次数最多的值）</li>
</ul>
<ol start="3">
<li>插值</li>
</ol>
<ul>
<li>Newton 插值法：但注意存在Runge现象，边缘存在震荡偏差。</li>
<li>样条插值：分段光滑曲线逼近，可保持节点光滑，规避突变。</li>
</ul>
<h2 id="excel" class="headerLink">
    <a href="#excel" class="header-mark"></a>Excel</h2><h3 id="常见问题" class="headerLink">
    <a href="#%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98" class="header-mark"></a>常见问题</h3><ol>
<li>单元格右上角红色三角形：链接到注释。</li>
<li>冻结窗格：锁定行列，滚动页面时一直可见。</li>
</ol>
<h3 id="函数7" class="headerLink">
    <a href="#%e5%87%bd%e6%95%b07" class="header-mark"></a>函数<sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup></h3><h4 id="计数" class="headerLink">
    <a href="#%e8%ae%a1%e6%95%b0" class="header-mark"></a>计数</h4><ul>
<li>COUNT</li>
<li>COUNTA（包含逻辑值等）</li>
<li>COUNTBLANK</li>
<li>COUNTIF</li>
<li>COUNTIFS</li>
</ul>
<h4 id="索引匹配" class="headerLink">
    <a href="#%e7%b4%a2%e5%bc%95%e5%8c%b9%e9%85%8d" class="header-mark"></a>索引匹配</h4><ul>
<li>LOOKUP</li>
<li>VLOOKUP</li>
</ul>
<h4 id="数学和金融函数" class="headerLink">
    <a href="#%e6%95%b0%e5%ad%a6%e5%92%8c%e9%87%91%e8%9e%8d%e5%87%bd%e6%95%b0" class="header-mark"></a>数学和金融函数</h4><ul>
<li>SQRT</li>
<li>DEGREE</li>
<li>RAND()</li>
<li>GCD</li>
</ul>
<h4 id="逻辑函数" class="headerLink">
    <a href="#%e9%80%bb%e8%be%91%e5%87%bd%e6%95%b0" class="header-mark"></a>逻辑函数</h4><ul>
<li>IF</li>
<li>AND</li>
<li>FALSE</li>
<li>TRUE</li>
</ul>
<h4 id="日期和时间函数" class="headerLink">
    <a href="#%e6%97%a5%e6%9c%9f%e5%92%8c%e6%97%b6%e9%97%b4%e5%87%bd%e6%95%b0" class="header-mark"></a>日期和时间函数</h4><ul>
<li>NOW()</li>
<li>DATEVALUE()</li>
<li>WEEKDAY(NOW())</li>
</ul>
<h4 id="替换" class="headerLink">
    <a href="#%e6%9b%bf%e6%8d%a2" class="header-mark"></a>替换</h4><ul>
<li>
<p><code>SUBSTITUTE(text, oldText, newText, [instanceNumber])</code></p>
</li>
<li>
<p><code>REPLACE(oldText, startNumber, NumberCharacters, newText)</code></p>
</li>
</ul>
<h3 id="数据透视表8" class="headerLink">
    <a href="#%e6%95%b0%e6%8d%ae%e9%80%8f%e8%a7%86%e8%a1%a88" class="header-mark"></a>数据透视表<sup id="fnref:8"><a href="#fn:8" class="footnote-ref" role="doc-noteref">8</a></sup></h3><h2 id="可视化tableau9" class="headerLink">
    <a href="#%e5%8f%af%e8%a7%86%e5%8c%96tableau9" class="header-mark"></a>可视化：Tableau<sup id="fnref:9"><a href="#fn:9" class="footnote-ref" role="doc-noteref">9</a></sup></h2><h3 id="常见问题10" class="headerLink">
    <a href="#%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%9810" class="header-mark"></a>常见问题<sup id="fnref:10"><a href="#fn:10" class="footnote-ref" role="doc-noteref">10</a></sup></h3><h2 id="数仓建设规范13" class="headerLink">
    <a href="#%e6%95%b0%e4%bb%93%e5%bb%ba%e8%ae%be%e8%a7%84%e8%8c%8313" class="header-mark"></a>数仓建设规范<sup id="fnref:11"><a href="#fn:11" class="footnote-ref" role="doc-noteref">11</a></sup></h2><h3 id="架构原则" class="headerLink">
    <a href="#%e6%9e%b6%e6%9e%84%e5%8e%9f%e5%88%99" class="header-mark"></a>架构原则</h3><h4 id="数仓分层" class="headerLink">
    <a href="#%e6%95%b0%e4%bb%93%e5%88%86%e5%b1%82" class="header-mark"></a>数仓分层</h4><ol>
<li>ODS 源</li>
<li>DW 明细 建模</li>
</ol>
<ul>
<li>DWD (Detail) 清理 规范化</li>
<li>DWM (Middle) 聚合 中间表</li>
<li>DWS (Service) 汇总 主题域服务数据 宽表（字段多）</li>
</ul>
<ol start="3">
<li>DM 轻汇总</li>
<li>APP 应用</li>
</ol>
<ul>
<li>数据产品 数据分析 报表</li>
</ul>
<ol start="5">
<li>维表层</li>
</ol>
<ul>
<li>高基数：资料表 数据量大</li>
<li>低基数：配置表</li>
</ul>
<h4 id="主题域划分" class="headerLink">
    <a href="#%e4%b8%bb%e9%a2%98%e5%9f%9f%e5%88%92%e5%88%86" class="header-mark"></a>主题域划分</h4><pre class="mermaid">graph LR;
    A[系统A] --> B(业务过程A)
    A[系统A] --> C(业务过程B)
    A[系统A] --> D(业务过程C)
    B --> E{主题域A}
    C --> F{主题域B}
    D --> G{主题域C}

</pre>
<ul>
<li>数据域：面向业务分析，将业务过程或维度进行抽象的集合。
<ul>
<li>业务过程：不可拆分的行为事件，可以定义指标，如买家下单事件</li>
<li>维度：度量环境，如买家是维度
为保障整个体系的生命力，数据域是需要抽象提炼，并且长期维护和更新的，但不轻易变动。在划分数据域时，既能涵盖当前所有的业务需求，又能在新业务进入时无影响地被包含进已有的数据域中和扩展新的数据域。</li>
</ul>
</li>
</ul>
<h4 id="数据模型设计" class="headerLink">
    <a href="#%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b%e8%ae%be%e8%ae%a1" class="header-mark"></a>数据模型设计</h4><p>普通全量表<sup id="fnref1:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup></p>
<h3 id="模型" class="headerLink">
    <a href="#%e6%a8%a1%e5%9e%8b" class="header-mark"></a>模型</h3><ol>
<li>星型模型：事实表+维度表</li>
</ol>
<h3 id="数据倾斜" class="headerLink">
    <a href="#%e6%95%b0%e6%8d%ae%e5%80%be%e6%96%9c" class="header-mark"></a>数据倾斜</h3><p>大量的数据集中到了一台或者几台机器上计算。</p>
<p>表现</p>
<ul>
<li>MapReduce：ruduce阶段卡在99.99%</li>
<li>Spark：个别task执行极慢</li>
</ul>
<p>分类</p>
<ul>
<li>频率倾斜：某区域数据量过多</li>
<li>大小倾斜：部分记录大小过大</li>
</ul>
<h2 id="hadoop" class="headerLink">
    <a href="#hadoop" class="header-mark"></a>Hadoop</h2><h2 id="实例尚硅谷-电商数仓1112" class="headerLink">
    <a href="#%e5%ae%9e%e4%be%8b%e5%b0%9a%e7%a1%85%e8%b0%b7-%e7%94%b5%e5%95%86%e6%95%b0%e4%bb%931112" class="header-mark"></a>实例：尚硅谷-电商数仓<sup id="fnref:12"><a href="#fn:12" class="footnote-ref" role="doc-noteref">12</a></sup><sup id="fnref:13"><a href="#fn:13" class="footnote-ref" role="doc-noteref">13</a></sup></h2><div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>大数据基础 @知乎用户MuDbXQ <a href="https://zhuanlan.zhihu.com/p/84554633" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/84554633</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>大数据(big data)：基础概念 @刘博 <a href="https://zhuanlan.zhihu.com/p/33619503" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/33619503</a>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>一文给小白讲清数据治理 @POINT小数点数据 <a href="https://zhuanlan.zhihu.com/p/388520475" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/388520475</a>&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p>什么是数据仓库？它和数据库的区别是什么？看这一篇就够了 @麦聪软件首席架构 <a href="https://zhuanlan.zhihu.com/p/433495465" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/433495465</a>&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a>&#160;<a href="#fnref1:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5">
<p>【基础】大数据技术栈介绍 @法映 <a href="https://zhuanlan.zhihu.com/p/138352849" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/138352849</a>&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6">
<p>缺失值的处理（数学建模-数据预处理） @数学建模BOOM <a href="https://zhuanlan.zhihu.com/p/402497542" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/402497542</a>&#160;<a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:7">
<p>Excel函数公式大全(图文详解) @真假斗士 <a href="https://zhuanlan.zhihu.com/p/436372294" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/436372294</a>&#160;<a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:8">
<p>Excel基础操作 @戴师兄 <a href="https://yrzu9y4st8.feishu.cn/mindnotes/bmncnOxqQPowAqr0iPzUZYFTirg" target="_blank" rel="noopener noreferrer">https://yrzu9y4st8.feishu.cn/mindnotes/bmncnOxqQPowAqr0iPzUZYFTirg</a>&#160;<a href="#fnref:8" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:9">
<p>Tableau数据可视化与仪表盘搭建 @戴师兄 <a href="https://yrzu9y4st8.feishu.cn/mindnotes/bmncnQCbk8yr68s4eBikgB06Awd" target="_blank" rel="noopener noreferrer">https://yrzu9y4st8.feishu.cn/mindnotes/bmncnQCbk8yr68s4eBikgB06Awd</a>&#160;<a href="#fnref:9" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:10">
<p>Tableau常见面试题和答案合集：求职面试必备 <a href="https://www.lsbin.com/15371.html" target="_blank" rel="noopener noreferrer">https://www.lsbin.com/15371.html</a>&#160;<a href="#fnref:10" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:11">
<p>最强最全面的数仓建设规范指南 @五分钟学大数据 <a href="https://yuanmore.blog.csdn.net/article/details/121265222" target="_blank" rel="noopener noreferrer">https://yuanmore.blog.csdn.net/article/details/121265222</a>&#160;<a href="#fnref:11" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:12">
<p><a href="https://www.bilibili.com/video/BV1yY411b72x/?vd_source=e81e93bc6892fd0d7e19b265d26a2b3a" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1yY411b72x/?vd_source=e81e93bc6892fd0d7e19b265d26a2b3a</a>&#160;<a href="#fnref:12" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:13">
<p>尚硅谷物流数仓笔记（数仓基础知识） @橘生淮南 <a href="https://zhuanlan.zhihu.com/p/647035072" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/647035072</a>&#160;<a href="#fnref:13" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>]]></description>
</item><item>
    <title>面向对象程序设计</title>
    <link>https://blog.ralvines.top/oop/</link>
    <pubDate>Wed, 01 Mar 2023 20:20:40 &#43;0800</pubDate><author>
                        <name>Ralvine</name><uri>https://blog.ralvines.top/about/praise/</uri><email>ralvine@163.com</email></author><guid>https://blog.ralvines.top/oop/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://z1.ax1x.com/2023/10/23/piAWIwd.png" referrerpolicy="no-referrer">
            </div><h2 id="介绍" class="headerLink">
    <a href="#%e4%bb%8b%e7%bb%8d" class="header-mark"></a>介绍</h2><p>Buzzwords</p>
<ul>
<li>继承</li>
<li>cohesion 凝聚</li>
<li>coupling 耦合</li>
<li>overriding</li>
<li>interface 接口</li>
<li>polymorphic 多态
<ul>
<li>polymorphic method calls</li>
</ul>
</li>
<li>matator methods</li>
<li>Encapsulation 封装</li>
</ul>
<p>C的优缺点&amp;C++新特性</p>
<h2 id="引用" class="headerLink">
    <a href="#%e5%bc%95%e7%94%a8" class="header-mark"></a>引用</h2><p>函数swap操作形参无法交换外部变量，C用指针，C++引入引用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span><span class="o">&amp;</span> <span class="n">SetValue</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">SetValue</span><span class="p">()</span><span class="o">=</span><span class="mi">40</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// Output: 40.
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="常量" class="headerLink">
    <a href="#%e5%b8%b8%e9%87%8f" class="header-mark"></a>常量</h2><p>区别define，有类型检查。</p>
<p>常量指针，不允许通过指针修改目标内容，但可以改变指向对象。</p>
<p>在函数形参中使用，防止形参被修改</p>
<p>常量成员函数：不应修改其所作用的对象（除了静态成员变量）</p>
<p>常量对象 <code>const Sample o;</code> 不可修改对象，但是可以执行其中的常量成员函数。</p>
<p>成员函数名字参数相同，有无const的区别属于重载关系。（实例对象是否常量决定了调用哪个成员函数）</p>
<p>常引用：对象作函数参数，为了避免复制构造函数降低效率，直接用引用，而为了防止实参跟着变，采用常引用。</p>
<h2 id="动态内存分配" class="headerLink">
    <a href="#%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d" class="header-mark"></a>动态内存分配</h2><p>分配变量：<code>int* P; P=new T;</code></p>
<p>T是任意类型名，相当于开辟了sizeof(T)的空间，P是指向它起始地址的指针，即T*.</p>
<p>释放：只能delete一次，对数组应为<code>delete [] p;</code></p>
<p>不delete就不会释放！</p>
<h2 id="内联函数重载和缺省参数" class="headerLink">
    <a href="#%e5%86%85%e8%81%94%e5%87%bd%e6%95%b0%e9%87%8d%e8%bd%bd%e5%92%8c%e7%bc%ba%e7%9c%81%e5%8f%82%e6%95%b0" class="header-mark"></a>内联函数、重载和缺省参数</h2><p>函数调用存在开销，调用本身耗时，内联函数在编译时直接插入函数内操作本身，但程序体积会变大。</p>
<p><code>inline int func(parameter) {}</code></p>
<p>函数名字相同但参数个数或类型不同，叫做重载。使函数命名简单，编译器自动判断调用哪个函数。二义性，调用函数的参数匹配不上。</p>
<p>缺省参数，最右边连续若干个参数可有缺省值。</p>
<p><code>void func(int x1, int x2=2, int x3=3) {}</code></p>
<h2 id="类和对象" class="headerLink">
    <a href="#%e7%b1%bb%e5%92%8c%e5%af%b9%e8%b1%a1" class="header-mark"></a>类和对象</h2><p>C语言：结构化程序设计，程序=数据结构+算法，但函数和操作的数据结构没有直接联系，规模增大后难以理解、扩充、查错。</p>
<p>C++：面向对象程序</p>
<p>指针方式：<code>ClassName* p= &amp;AClassObject</code>，用 - &gt; 指向其成员变量或函数。</p>
<p>引用方式：<code>ClassName&amp; p= AClassObject</code> 同时跟着变。</p>
<p>私有成员：缺省=private，同Class其他对象的私有成员也可访问。</p>
<p>成员函数也可重载、参数缺省。</p>
<h2 id="构造函数" class="headerLink">
    <a href="#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0" class="header-mark"></a>构造函数</h2><p>一个类可以有多个构造函数。</p>
<p>对象数组，注意动态分配时没定义就不初始化。</p>
<p>复制构造函数，参数必须引用<code>X::X(X&amp; x)</code>；起作用：直接<code>Complex c2(c1)</code>，或者函数参数或返回值含有该类对象；但是对象间赋值不会调用复制构造函数。</p>
<p>常量引用参数：减少开销，确保实参值不变时使用。</p>
<p>类型转换构造函数：只含一个参数。</p>
<p>析构函数：有对象数组情况下，程序结束时每个元素都会调用析构函数；临时对象和形参对象消亡都会调用。</p>
<p>局部对象：<code>{ 生命周期 }</code>，静态对象static：函数结束时不消亡。</p>
<p>不同编译器输出有所差别，有的做了优化，赋值可以不用再临时生成被复制的对象。</p>
<h2 id="this指针" class="headerLink">
    <a href="#this%e6%8c%87%e9%92%88" class="header-mark"></a>this指针</h2><p>C++编译先翻译成C时，Class变为Struct，因此需要多一个this指针指向函数作用的对象。因此可以返回对象自身。</p>
<p>静态成员函数则不可使用this指针，因为其不具体作用于某个对象。</p>
<h2 id="静态成员变量" class="headerLink">
    <a href="#%e9%9d%99%e6%80%81%e6%88%90%e5%91%98%e5%8f%98%e9%87%8f" class="header-mark"></a>静态成员变量</h2><p>静态成员为所有对象共享，总共就一份。sizeof()计算对象时不会计算其static成员变量。</p>
<p>访问方式。需要在定义类的文件中单独进行声明或初始化！</p>
<p>静态成员<strong>函数</strong>还可以直接通过整个类进行调用。</p>
<p>本质是全局变量，只是放在类中。例：方体类的实例总数。</p>
<p>⬆️缺陷，若实例对象是复制构造生成的，Total会有遗漏，特别是临时对象消亡时还会调用析构函数，因此需要单独写一个复制构造函数。</p>
<p>静态成员<strong>函数</strong>不能调用非静态的成员变量或函数。</p>
<h2 id="成员对象和封闭类" class="headerLink">
    <a href="#%e6%88%90%e5%91%98%e5%af%b9%e8%b1%a1%e5%92%8c%e5%b0%81%e9%97%ad%e7%b1%bb" class="header-mark"></a>成员对象和封闭类</h2><p>Class中有成员变量为其他Class类型，即称其为成员对象。例如Class Car下有成员变量Engine，属于Engine类。</p>
<p>初始化列表：构造函数后直接赋值。</p>
<p>先执行封闭类下所有对象成员构造函数，再执行封闭类构造函数；析构时顺序相反。</p>
<h2 id="友元" class="headerLink">
    <a href="#%e5%8f%8b%e5%85%83" class="header-mark"></a>友元</h2><p>友元类，关系不能传递和继承。</p>
<h2 id="运算符重载" class="headerLink">
    <a href="#%e8%bf%90%e7%ae%97%e7%ac%a6%e9%87%8d%e8%bd%bd" class="header-mark"></a>运算符重载</h2><p>根据参数数目决定重载为成员函数或普通函数</p>
<p>赋值运算符的重载：以string为例，需要防止指向同一块内存。</p>
<p>此时返回对象需要引用，如<code>String&amp;</code>：应当保留运算符原本特性，使得允许a=b=c和(a=b)=c.</p>
<p>还需要防止s=s.</p>
<p>还需要为其写单独的复制构造函数。</p>
<p>若声明时直接赋值，属于调用构造函数。</p>]]></description>
</item><item>
    <title>偏微分方程绪论</title>
    <link>https://blog.ralvines.top/pde/</link>
    <pubDate>Wed, 01 Mar 2023 20:20:40 &#43;0800</pubDate><author>
                        <name>Ralvine</name><uri>https://blog.ralvines.top/about/praise/</uri><email>ralvine@163.com</email></author><guid>https://blog.ralvines.top/pde/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://z1.ax1x.com/2023/10/23/piAW5eH.png" referrerpolicy="no-referrer">
            </div><h2 id="发展史" class="headerLink">
    <a href="#%e5%8f%91%e5%b1%95%e5%8f%b2" class="header-mark"></a>发展史</h2><blockquote>
<p>17 - 微积分 Newton &amp; Lebnitz<br>
18 - Euler &amp; Bernoulli &amp; Lagrange &amp; Laplace &amp; Poisson<br>
19 - pde应用 Fourier &amp; Green &amp; Cauchy &amp; Hadamard<br>
20 - 复杂理论<br>
21 - 计算机数值分析 &amp; 微分方程数值解</p>
</blockquote>
<h2 id="基本定义" class="headerLink">
    <a href="#%e5%9f%ba%e6%9c%ac%e5%ae%9a%e4%b9%89" class="header-mark"></a>基本定义</h2><h3 id="概念" class="headerLink">
    <a href="#%e6%a6%82%e5%bf%b5" class="header-mark"></a>概念</h3><ul>
<li>
<p><strong>向量：</strong> 开区域 $$x=(x_1,x_2,\cdots,x_n)\in \mathbb{R}^n,x\in \Omega$$</p>
</li>
<li>
<p><strong>函数：</strong>
$$u:\Omega\rightarrow\mathbb{R}$$
$$偏导\ \displaystyle\frac{\partial u}{\partial x_1}=\partial_{x_{1}}u=\partial_{1}u$$</p>
</li>
<li>
<p><strong>梯度：</strong>$$grad/\nabla/Du=(\partial_{1}u,\partial_{2}u,\cdots,\partial_{n}u)$$</p>
</li>
<li>
<p><strong>散度：</strong>$$\vec{F}=(F_1,F_2,\cdots,F_n),\Omega\rightarrow \mathbb{R}^n\Rightarrow div\vec{F}=\displaystyle\sum\limits_{i=1}^n\frac{\partial F_i}{\partial x_i}$$</p>
</li>
<li>
<p><strong>Hessian矩阵：</strong> $$D^2u=\begin{pmatrix}\displaystyle\frac{\partial^2u}{\partial x_1^2}&\displaystyle\frac{\partial^2 u}{\partial x_1x_2}&\cdots&\displaystyle\frac{\partial^2u}{\partial x_1x_n}\\\vdots&\vdots&\ddots&\vdots\\\displaystyle\frac{\partial^2u}{\partial x_nx_1}&\displaystyle\frac{\partial^2u}{\partial x_nx_2}&\cdots&\displaystyle\frac{\partial^2u}{\partial x_n^2}\end{pmatrix}$$</p>
</li>
<li>
<p><strong>Laplace算子：</strong> $$\Delta u=tr(D^2u)=\displaystyle\sum\limits_{i=1}^n\frac{\partial ^2u}{\partial x_i^2}=\text{div}(Du)\ 散度的梯度$$</p>
</li>
<li>
<p><strong>所有k阶偏导：</strong>
$$D^ku=\displaystyle\frac{\partial^ku}{\partial x_{i1}\partial x_{i2}\cdots\partial x_{ik}}\in\mathbb{R}^{n^k},\ n^k个$$
$$|D^ku|=(\sum\limits_{i1=1}^n\sum\limits_{i2=1}^n\cdots\sum\limits_{ik=1}^n|\partial_{x1}\partial_{x2}\cdots\partial_{xk}u|)^{1/2}$$</p>
</li>
<li>
<p><strong>多重指标：</strong>
$$\alpha=(\alpha_1,\alpha_2,\cdots,\alpha_n),$$
$$阶\ |\alpha|=\alpha_1+\alpha_2+\cdots+\alpha_n$$
$$去重\ D^\alpha u=\partial_{x1}^{\alpha1}\partial_{x1}^{\alpha2}\cdots\partial_{x1}^{\alpha n}\Rightarrow|D^ku|=(\sum\limits_{|\alpha|=k}|D^\alpha u|^2)^{1/2}$$</p>
</li>
<li>
<p><strong>偏微分方程：</strong>
 
$$F(D^ku(x),D^{k-1}u(x),\cdots,Du(x),u(x),x)=0, x\in\Omega.\ k阶$$

$$\left\{\begin{array}{l}
F:\mathbb{R}^{n^k}\times\mathbb{R}^{n^{k-1}}\times\cdots\times\mathbb{R}^{n}\times\mathbb{R}\times\Omega\rightarrow\mathbb{R}.（已知）\\
u:\Omega\rightarrow\mathbb{R}.（未知）\\
\end{array}\right.$$
</p>
</li>
</ul>
<h3 id="线性空间" class="headerLink">
    <a href="#%e7%ba%bf%e6%80%a7%e7%a9%ba%e9%97%b4" class="header-mark"></a>线性空间</h3><ul>
<li>
<p><strong>函数：</strong>
 
$$u\rightarrow C(\Omega), ||u||_{C(\Omega)}=\sup\limits_{x\in\Omega} |u(x)|.$$
</p>
</li>
<li>
<p><strong>k次连续可微函数：</strong>
 
$$ ||u||_{C^k(\Omega)}=\sup\limits_{x\in\Omega}|u(x)| + \displaystyle\sum\limits_{|\alpha|=1}^2 \sup\limits_{x\in\Omega}|D^\alpha u(x)| $$
</p>
</li>
<li>
<p><strong>支集：</strong>

$$spt\space u=\overline{\{ x\in\Omega|u(x)\neq0\}}.$$

所有满足$u(x)\neq0$点集在$\Omega$上的闭包</p>
</li>
<li>
<p>$C_0^k$ 具有紧支集的函数</p>
</li>
<li>
<p>$C^\infty(\Omega)=\bigcap\limits_{k=1}^\infty C^k(\Omega)$任意阶偏导存在且连续的函数类</p>
</li>
</ul>
<h3 id="解的光滑性" class="headerLink">
    <a href="#%e8%a7%a3%e7%9a%84%e5%85%89%e6%bb%91%e6%80%a7" class="header-mark"></a>解的光滑性</h3><center>解析 $\rightarrow$ 无穷光滑 $\rightarrow$ k次连续可微(古典解) $\rightarrow$ 弱解(广义解)</center>
<h3 id="分类" class="headerLink">
    <a href="#%e5%88%86%e7%b1%bb" class="header-mark"></a>分类</h3><ul>
<li>
<p><strong>线性：</strong>$\displaystyle\sum\limits_{|\alpha|\leq k}a_{\alpha}(x)D^{\alpha}u=f(x)$</p>
</li>
<li>
<p><strong>半线性：</strong>$\displaystyle\sum\limits_{|\alpha|=k}a_{\alpha}(x)D^{\alpha}u=f[D^{k-1}u(x),\cdots,Du(x),u(x),x]$</p>
</li>
<li>
<p><strong>拟线性：</strong>$\displaystyle\sum\limits_{|\alpha|=k}a_{\alpha}[D^{k-1}u(x),\cdots,Du(x),u(x),x]D^{\alpha}u=f[D^{k-1}u(x),\cdots,Du(x),u(x),x]$</p>
</li>
<li>
<p>完全非线性：非线性依赖 $D^ku$</p>
</li>
</ul>
<h2 id="实例" class="headerLink">
    <a href="#%e5%ae%9e%e4%be%8b" class="header-mark"></a>实例</h2><ol>
<li><strong>Laplace方程：</strong>$\Delta u=0$</li>
<li><strong>特征值方程：</strong>$\Delta u+\lambda u=0$</li>
<li><strong>热方程：</strong>$u_t-a^2\Delta u=0(a&gt;0)$</li>
<li>&hellip;</li>
</ol>
<!-- ## 椭圆型&

## 适定性

### 定义

- 定解问题：PDE+条件

- 适定：解存在、唯一、连续依赖已知函数

- 形式解：对实际问题假设解的光滑性以求出表达式（先验估计）

- $\Omega$ - 开域、$\overline\Omega$ - 闭包、$\partial\Omega$ - 边界

   $\mathbb{R}_+^n=\{x=(x_1,\cdots,x_n)\in\mathbb{R}^n|x_n>0\}$ 上半空间 <br>
  
   $\mathbb{R}_+^1=\mathbb{R}_+,\space\mathbb{R}_+^{n+1}=\mathbb{R}_+^n\times\mathbb{R}_+$ 

- **闭球：**$B(x,r),$ 体积 $\alpha(n)r^n$


### 定理

- **Green 公式**

# 位势方程

## Possion方程

$$-\Delta u=f(x)$$

## 调和函数

$$\displaystyle\int_a^b\hspace{-1.5em}-\ f(x)\, \mathrm{d}x$$

# 热方程

## 基本定义

### 热方程

- **基本形式：**$u_t-a^2\Delta u=f,\space u(x,t),\space f(x,t),\space x\in\Omega\subset\mathbb{R^n},t>0$
- **推导**
- 反应扩散方程：反应项、扩散项

### 概念

- **定解问题：**

  - **定解条件**

    - **初始条件：**$u(x,0)=\varphi (x)$

    - **边值条件：** 边界分布或外围介质影响（$x\in\partial\Omega,t\ge0$）

      $u(x,t)=g(x,t)$. $g=\text{const}$ 恒温
      
      $k\frac{\partial}{\partial\displaystyle\vec{n}}u(x,t)=g(x,t)$. $g\ge0$ 热量流入；$g\equiv0$ 绝热

  - **偏微分方程**

- **函数集：** 所有$Q$内关于$x$二阶偏导连续，关于$t$一阶偏导连续函数
  
   $C^{2,1}(Q)=\{u\in C(Q)|u_t, u_{xi},u_{xixj}\in C(Q);i,j=1,\cdots,n\}$ 

- **古典解：** 热方程在上述集中的解

- $C^{1,0}(Q)$

## 初值问题

### Fourier

- **Fourier 级数展开**

  $f(x)\in C^1(\mathbb{R}),\space\forall l>0,\space x\in(-l,l)$

  $f(x)=\displaystyle\frac{a_0}{2}+\displaystyle\sum\limits_{k=1}^\infty \big (a_k\cos \displaystyle\frac{k\pi}{l}x+b_k\sin\displaystyle\frac{k\pi}{l}x\big )$

- **Fourier 积分：** 级数极限

### 一维热方程初值问题


$$
\displaystyle\left\{\begin{array}{l}
 \displaystyle\frac{\partial{u}}{\partial t}-a^2\displaystyle\frac{\partial^2u}{\partial x^2}=f(x,t), & (x,t)\in\mathbb{R}\times\mathbb{R}_+\\
u(x,0)=\varphi(x), & x\in\mathbb
{R}\\
  \end{array}\right.
$$

 -->]]></description>
</item><item>
    <title>数据结构与算法</title>
    <link>https://blog.ralvines.top/dsa/</link>
    <pubDate>Wed, 01 Sep 2021 20:20:40 &#43;0800</pubDate><author>
                        <name>Ralvine</name><uri>https://blog.ralvines.top/about/praise/</uri><email>ralvine@163.com</email></author><guid>https://blog.ralvines.top/dsa/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://z1.ax1x.com/2023/10/23/piAW5eH.png" referrerpolicy="no-referrer">
            </div><h2 id="c-基础知识" class="headerLink">
    <a href="#c-%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86" class="header-mark"></a>C++ 基础知识</h2><h3 id="动态内存与释放" class="headerLink">
    <a href="#%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98%e4%b8%8e%e9%87%8a%e6%94%be" class="header-mark"></a>动态内存与释放</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">;</span> <span class="k">delete</span> <span class="p">[]</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Birds</span><span class="p">()</span> <span class="p">{</span><span class="n">name</span><span class="o">=</span><span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">256</span><span class="p">]}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>利用指针实现动态内存分配。同值对象指向相同address</p>
<p>Shell命令查看内存泄漏状况<code>valgrind filename</code></p>
<p>释放内存：及时delete变量。由于为指针，要防止指向新地址时原内存未被释放。</p>
<h3 id="template" class="headerLink">
    <a href="#template" class="header-mark"></a>template</h3><p>编译时自动填充typename
在类外撰写类成员函数时需要添加
可指定T的具体类型</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">FunctionName</span><span class="p">(</span><span class="k">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">_obj</span><span class="p">)</span> <span class="p">{}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="关键字修饰符" class="headerLink">
    <a href="#%e5%85%b3%e9%94%ae%e5%ad%97%e4%bf%ae%e9%a5%b0%e7%ac%a6" class="header-mark"></a>关键字修饰符</h3><h4 id="const" class="headerLink">
    <a href="#const" class="header-mark"></a>const</h4><p>对成员函数：修饰非静态数据，只读化。应尽可能将该成员函数声明为const 成员函数，除非成员函数需要修改数据成员。const可访问非常量数据，反之不可。指针数据可以被const 函数修改。
<code>Class:: func() const {}</code></p>
<p>对形参：指针传递，禁止修改指针指向地址内存数据；值传递不需要const保护。</p>
<p><code>void copyMemory(const T* _s,T* _d,int _n);</code></p>
<h4 id="static" class="headerLink">
    <a href="#static" class="header-mark"></a>static</h4><p>静态变量，延长生命周期又相较全局变量保留了一定的访问范围。需要一个数据对象为整个类而非某个对象服务,同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部时使用。</p>
<h4 id="this" class="headerLink">
    <a href="#this" class="header-mark"></a>*this</h4><p>指向obj自身的指针</p>
<h4 id="explicit-显式转换" class="headerLink">
    <a href="#explicit-%e6%98%be%e5%bc%8f%e8%bd%ac%e6%8d%a2" class="header-mark"></a>explicit 显式转换</h4><p><code>explicit</code> 对单参数构造函数限制隐式转换
防止编译器进行类型等方式的强制转换。</p>
<h3 id="宏定义" class="headerLink">
    <a href="#%e5%ae%8f%e5%ae%9a%e4%b9%89" class="header-mark"></a>宏定义</h3><p>用于简化重复语句<code>#define TEMP template&lt;typename T&gt;</code></p>
<p>编译处理</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#ifndef xxx
</span></span></span><span class="line"><span class="cl"><span class="cp">#define xxx
</span></span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="传递-引用" class="headerLink">
    <a href="#%e4%bc%a0%e9%80%92-%e5%bc%95%e7%94%a8" class="header-mark"></a>传递 引用</h3><h4 id="形参的值传递-指针传递-引用传递" class="headerLink">
    <a href="#%e5%bd%a2%e5%8f%82%e7%9a%84%e5%80%bc%e4%bc%a0%e9%80%92-%e6%8c%87%e9%92%88%e4%bc%a0%e9%80%92-%e5%bc%95%e7%94%a8%e4%bc%a0%e9%80%92" class="header-mark"></a>形参的值传递 指针传递 引用传递</h4><p>默认为值传递，开辟新函数，储存实参数据；指针实质存在一层中介地址，引用传递直接对传入对象进行修改；</p>
<p><code>*&amp;obj</code> 适用于struct对象，对其属性变量进行修改</p>
<ol>
<li><code>T* a</code> ： 传递实参指针地址，及最终指向数据地址，但可以利用*a修改地址内存数据</li>
<li><code>T&amp; a</code> ：左值引用，实参的别名</li>
</ol>
<h4 id="左值-右值引用" class="headerLink">
    <a href="#%e5%b7%a6%e5%80%bc-%e5%8f%b3%e5%80%bc%e5%bc%95%e7%94%a8" class="header-mark"></a>左值 右值引用</h4><p>右值引用 <code>&amp;&amp;</code> ：防止传递给形参 <code>T&amp; a</code> 的是常量（此时函数无法修改a）</p>
<p><strong>看能不能对表达式取地址，如果能，则为左值，否则为右值</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">&amp;</span><span class="n">d</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// error.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">d</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>约定</strong> rhs：引用；lhs：赋值</p>
<h3 id="stdmove" class="headerLink">
    <a href="#stdmove" class="header-mark"></a>std::move</h3><p>强制将左值转换为右值引用，如 <code>push_back</code> 避免开辟新内存</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">AvlNode</span><span class="p">(</span><span class="k">const</span> <span class="n">Comparable</span> <span class="o">&amp;</span> <span class="n">ele</span><span class="p">,</span> <span class="n">AvlNode</span> <span class="o">*</span><span class="n">lt</span><span class="p">,</span> <span class="n">AvlNode</span> <span class="o">*</span><span class="n">rt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span> <span class="n">element</span><span class="p">{</span><span class="n">ele</span><span class="p">},</span> <span class="n">left</span><span class="p">{</span><span class="n">lt</span><span class="p">},</span> <span class="n">right</span><span class="p">{</span><span class="n">rt</span><span class="p">},</span> <span class="n">height</span><span class="p">{</span><span class="n">h</span><span class="p">}</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="n">AvlNode</span><span class="p">(</span><span class="n">Comparable</span> <span class="o">&amp;&amp;</span> <span class="n">ele</span><span class="p">,</span> <span class="n">AvlNode</span> <span class="o">*</span><span class="n">lt</span><span class="p">,</span> <span class="n">AvlNode</span> <span class="o">*</span><span class="n">rt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span> <span class="n">element</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ele</span><span class="p">)},</span> <span class="n">left</span><span class="p">{</span><span class="n">lt</span><span class="p">},</span> <span class="n">right</span><span class="p">{</span><span class="n">rt</span><span class="p">},</span> <span class="n">height</span><span class="p">{</span><span class="n">h</span><span class="p">}</span> <span class="p">{}</span> <span class="c1">//参数无地址，临时ele=参数
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="class--struct-封装" class="headerLink">
    <a href="#class--struct-%e5%b0%81%e8%a3%85" class="header-mark"></a>Class &amp; Struct 封装</h3><p>外部只提供相应功能的接口，不允许直接对底层对象进行修改。</p>
<h4 id="复制构造函数" class="headerLink">
    <a href="#%e5%a4%8d%e5%88%b6%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0" class="header-mark"></a>复制构造函数</h4><p>将b中成员属性复制到c： <code>Birds c(b);</code>
类中处理：定义拷贝函数；否则：缺省。
需要开辟新的动态内存</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Birds</span><span class="p">(</span><span class="n">Birds</span> <span class="n">_obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">name</span><span class="o">=</span><span class="k">new</span> <span class="kt">char</span> <span class="p">[</span><span class="mi">256</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl"><span class="n">for循环迭代载入name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">_obj</span><span class="p">.</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="函数化" class="headerLink">
    <a href="#%e5%87%bd%e6%95%b0%e5%8c%96" class="header-mark"></a>函数化</h4><p>如复制构造函数中的copyMemory，便于多核并行运算。</p>
<h4 id="struct-定义传入参数" class="headerLink">
    <a href="#struct-%e5%ae%9a%e4%b9%89%e4%bc%a0%e5%85%a5%e5%8f%82%e6%95%b0" class="header-mark"></a>struct 定义传入参数</h4><p>使得struct能够直接在定义时传入相应参数</p>
<p><code>BinaryNode(const Comparable&amp; theElement, BinaryNode *lt, BinaryNode *rt): element(theElement),left(lt),right(rt) {}</code></p>
<h4 id="operator-重载运算符" class="headerLink">
    <a href="#operator-%e9%87%8d%e8%bd%bd%e8%bf%90%e7%ae%97%e7%ac%a6" class="header-mark"></a>Operator 重载运算符</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">const Array&amp; operator=(const Array&amp; _obj)
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="注释" class="headerLink">
    <a href="#%e6%b3%a8%e9%87%8a" class="header-mark"></a>注释</h3><p>doxymacs/doxygen格式的注释：
可以通过命令提取所有相应注释以html方式直观显示。</p>
<h3 id="standard-template-library" class="headerLink">
    <a href="#standard-template-library" class="header-mark"></a>Standard Template Library</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// get random number.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">srand</span><span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">time</span><span class="p">(</span><span class="k">nullptr</span><span class="p">));</span> <span class="c1">// 随机种子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">a</span><span class="o">=</span><span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="mi">10</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">abs</span><span class="p">();</span><span class="n">min</span><span class="p">();</span><span class="n">max</span><span class="p">();</span><span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">sqrt</span><span class="p">();</span><span class="n">sin</span><span class="p">();</span><span class="n">cos</span><span class="p">();</span><span class="n">tan</span><span class="p">();</span><span class="n">pow</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">clock_t</span> <span class="n">start</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="复杂度" class="headerLink">
    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6" class="header-mark"></a>复杂度</h2><h3 id="big-o" class="headerLink">
    <a href="#big-o" class="header-mark"></a>big O</h3><p>$1000N=O(N^2); (logN)^k=O(N);$</p>
<p>$1 &lt; logN &lt; N &lt; NlogN &lt; N^2$</p>
<h3 id="时间复杂度" class="headerLink">
    <a href="#%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6" class="header-mark"></a>时间复杂度</h3><ul>
<li>for循环｜内语句*迭代次数；嵌套循环</li>
<li>顺序语句｜求和，取Max；判定语句</li>
<li>NlogN|最大子序列问题 一次N遍历&amp;一次二分查找</li>
<li>logN｜二分搜索，欧几里得</li>
</ul>
<h2 id="主定理" class="headerLink">
    <a href="#%e4%b8%bb%e5%ae%9a%e7%90%86" class="header-mark"></a>主定理</h2><p><strong>归纳法证明：</strong></p>
<p>（例）</p>
<p><strong>一般性证明：</strong></p>
<p>构造树，$\text{depth}=log(b,n)，\text{widget}=a^{(log(b,n))}=n^{(log(b,a))}$</p>


    <div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw"></i>实例：二分查找<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>$T(n) = T(n/2) + O(1)$</p>
<p>$T(n/2) = T(n/4) + O(1)$</p>
<p>$&hellip;$</p>
<p>$T(2) = T(1) + O(1)$</p>
<p>$T(1) = O(1)$</p>
<p>$a=1,b=2,k=0$ 代入得 $O(logN)$;</p>
</div>
        </div>
    </div>

    
<p>另可直接证，由于为$1/2,1/4&hellip;1/n$, 尾项$2^k$项为$n$，故共$logn$项，$$T(n)=logn\times o(1)=logn$$</p>
<h2 id="vector--list--stack--queues" class="headerLink">
    <a href="#vector--list--stack--queues" class="header-mark"></a>Vector &amp; List &amp; Stack &amp; Queues</h2><h3 id="iterator" class="headerLink">
    <a href="#iterator" class="header-mark"></a>iterator</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">iterator</span> <span class="n">a</span><span class="o">=</span><span class="n">A</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">i</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="vector--list" class="headerLink">
    <a href="#vector--list" class="header-mark"></a>Vector &amp; List</h3><ul>
<li>Array | 经典数组</li>
<li>Vector | 批量分配内存的数组，空间不够时再申请新的内存；模板化<code>&lt;T&gt;</code>；允许拷贝赋值</li>
<li>List | 链表 Single/Double-Linked-List <strong>双链表</strong> 表头、尾、哨兵结点</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//10个初值为1的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">b</span><span class="p">.</span><span class="n">begin</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//共有
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">a</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="n">a</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="p">.</span><span class="n">front</span><span class="p">();</span><span class="n">a</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span><span class="c1">//现有元素数目调整,多删少补,未给定参数2则随机
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Vector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="n">a</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span><span class="n">a</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span><span class="c1">//容量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// List
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">a</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="n">a</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">single_val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="n">a</span><span class="p">.</span><span class="n">remove_if</span><span class="p">(</span><span class="n">condition</span><span class="p">);</span><span class="n">a</span><span class="p">.</span><span class="n">unique</span><span class="p">();</span><span class="c1">//去重
</span></span></span></code></pre></td></tr></table>
</div>
</div><table>
<thead>
<tr>
<th>类型</th>
<th>Access</th>
<th>Insert</th>
<th>Delete</th>
<th>Search</th>
</tr>
</thead>
<tbody>
<tr>
<td>Array/Vector</td>
<td>1</td>
<td>n</td>
<td>n</td>
<td>n</td>
</tr>
<tr>
<td>Single-linked-List</td>
<td>n</td>
<td>1</td>
<td>1</td>
<td>n</td>
</tr>
<tr>
<td>Double-linked-List</td>
<td>n</td>
<td>1</td>
<td>1</td>
<td>n</td>
</tr>
</tbody>
</table>
<h3 id="stack--queue" class="headerLink">
    <a href="#stack--queue" class="header-mark"></a>Stack &amp; Queue</h3><p><code>pop() push() size() swap() empty();</code></p>
<ul>
<li>Stack: LIFO <code>top();</code></li>
<li>Queue: FIFO <code>front() back();</code></li>
</ul>
<h4 id="stack-计算器" class="headerLink">
    <a href="#stack-%e8%ae%a1%e7%ae%97%e5%99%a8" class="header-mark"></a>Stack 计算器</h4><ul>
<li>前缀/后缀。</li>
<li><strong>中缀转后缀：</strong><code>A+B*(C-D)-E/F</code>转为<code>ABCD−∗+EF/−</code></li>
</ul>
<p>优先级设置 <code>‘*’ = ‘/’ &gt; ‘+’ = ‘-’ &gt;</code></p>
<ul>
<li>style1: <code>‘(’</code> 优先级最高，如直接读入；推入操作符时不弹</li>
<li>style2: <code>‘(’</code> 优先级最低，强制直接读入</li>
<li>数字直接放到[输出列]，右括号直接弹到左括号止；</li>
<li>操作符：栈弹出直到遇到比自己优先级低的操作符再入栈。</li>
<li>计算：顺序读取，数字入栈，符号弹出两数字运算，结果入栈。</li>
</ul>
<h2 id="树" class="headerLink">
    <a href="#%e6%a0%91" class="header-mark"></a>树</h2><p>Binary Tree 二叉树平均深度 $O(\sqrt{N})$ ，表达式树应用；</p>
<h3 id="二叉搜索树" class="headerLink">
    <a href="#%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91" class="header-mark"></a>二叉搜索树</h3><p>左小右大；平均深度 $O(logN)$ ，最坏深度 $O(N-1)$.</p>
<h4 id="构建" class="headerLink">
    <a href="#%e6%9e%84%e5%bb%ba" class="header-mark"></a>构建</h4><ul>
<li><code>contains</code>｜<code>findMin(Max)</code>｜<code>insert</code>｜<code>～</code></li>
<li><code>makeEmpty</code> 递归</li>
<li><code>copy</code> | clone，递归 <code>return new node</code>;</li>
<li>重载运算符：<code>this!=&amp;rhs</code> 则 <code>makeEmpty</code> 再 <code>clone rhs.root</code> ，最终 <code>return *this</code></li>
<li><code>remove</code> | <code>(*&amp;t)t</code> 为结点地址；空, <code>return</code>; <code>t&lt;&gt;x</code> 判断; <code>t=x</code>.</li>
<li>双子: <code>t-&gt;ele=findmax(t-&gt;right)-&gt;ele</code> , <code>remove(t-&gt;ele;t-&gt;right); // 右子找min代入t,删除该min</code></li>
<li>单子/无子: <code>T*oldNode=t</code> ,另引入的参数 <code>t=t-&gt;left/right</code> 相当于改结点地址为 t 左/右子，再删 <code>oldNode</code> 即删了原结点.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// findmin: 递归或while 注意空树直接返回nullptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BinaryNode</span> <span class="o">*</span> <span class="nf">findMin</span><span class="p">(</span> <span class="n">BinaryNode</span> <span class="o">*</span><span class="n">t</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">t</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">findMin</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// insert
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mf">1.</span><span class="k">if</span> <span class="n">t</span><span class="o">==</span><span class="k">nullptr</span><span class="o">:</span><span class="k">new</span> <span class="n">node</span><span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="k">nullptr</span><span class="p">,</span><span class="k">nullptr</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="mf">2.</span><span class="k">else</span> <span class="n">compare</span> <span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ele</span><span class="p">,</span><span class="err">递归</span>
</span></span><span class="line"><span class="cl"><span class="mf">3.</span><span class="n">balance</span> <span class="n">and</span> <span class="n">update</span> <span class="n">the</span> <span class="n">height</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">subtree</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">).</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="关于-struct-构造" class="headerLink">
    <a href="#%e5%85%b3%e4%ba%8e-struct-%e6%9e%84%e9%80%a0" class="header-mark"></a>关于 struct 构造</h4><ul>
<li><code>BinaryNode</code> 置于 private；针对 <code>struct</code> 的操作也位于 private 部分</li>
<li>外部操作 $\rightarrow$ public函数 $\rightarrow$ private函数</li>
</ul>
<h4 id="关于-function-参数" class="headerLink">
    <a href="#%e5%85%b3%e4%ba%8e-function-%e5%8f%82%e6%95%b0" class="header-mark"></a>关于 function 参数</h4><p>对 <code>Struct BinaryNode</code>，由于其 <code>element</code> 为变量，<code>left/right</code> 为指针，fuction 引用时应采用 <code>BinaryNode * &amp; t</code> ，引用 Node 地址。</p>
<h4 id="时间分析" class="headerLink">
    <a href="#%e6%97%b6%e9%97%b4%e5%88%86%e6%9e%90" class="header-mark"></a>时间分析</h4><ul>
<li>
<p>内部路径长｜所有结点的深度和</p>
</li>
<li>
<p>递推关系、秩，(average) $$D(N)=D(i)+D(N-i-1)+N-1 \Rightarrow O(NlogN)$$</p>
</li>
<li>
<p>任意结点预期深度 $logN$</p>
</li>
<li>
<p>交替 <code>insert/remove</code> $O(N^2)$ ，期望深度 $O(\sqrt{N})$</p>
</li>
</ul>
<h3 id="balance-树" class="headerLink">
    <a href="#balance-%e6%a0%91" class="header-mark"></a>Balance 树</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">/// Height 处理
</span></span></span><span class="line"><span class="cl"><span class="c1">// Binary Tree
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">height</span><span class="p">(</span> <span class="n">BinaryNode</span> <span class="o">*</span><span class="n">t</span> <span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">t</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">max</span><span class="p">(</span><span class="n">height</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">),</span> <span class="n">height</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// AVL Tree: Struct AvlNode has added the val &#39;height&#39;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">height</span><span class="p">(</span> <span class="n">AvlNode</span> <span class="o">*</span><span class="n">t</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">t</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="avl-树" class="headerLink">
    <a href="#avl-%e6%a0%91" class="header-mark"></a>AVL 树</h4><p>每个结点的左子树和右子树高度最多差1（空树为-1）</p>
<p><strong>Rotation的具体实现</strong></p>
<table>
<thead>
<tr>
<th>插入方式</th>
<th>描述</th>
<th>旋转方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>LL</td>
<td>在a的<strong>左子树</strong>根节点的<strong>左子树</strong>上插入节点而破坏平衡</td>
<td>右旋转</td>
</tr>
<tr>
<td>RR</td>
<td>在a的<strong>右子树</strong>根节点的<strong>右子树</strong>上插入节点而破坏平衡</td>
<td>左旋转</td>
</tr>
<tr>
<td>LR</td>
<td>在a的<strong>左子树</strong>根节点的<strong>右子树</strong>上插入节点而破坏平衡</td>
<td>先左旋后右旋</td>
</tr>
<tr>
<td>RL</td>
<td>在a的<strong>右子树</strong>根节点的<strong>左子树</strong>上插入节点而破坏平衡</td>
<td>先右旋后左旋</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// insert. 伪代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">x</span><span class="o">&lt;</span><span class="n">t</span><span class="o">-&gt;</span><span class="nl">ele</span><span class="p">:</span><span class="err">左插入，</span><span class="n">insert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">),</span><span class="err">此时判定</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="n">balance</span> <span class="nl">condition</span><span class="p">:</span><span class="n">height</span> <span class="n">of</span> <span class="n">left</span><span class="o">-</span><span class="n">right</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">then</span> <span class="k">if</span> <span class="n">x</span><span class="o">&lt;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">ele</span> <span class="err">即</span><span class="n">LL</span><span class="err">，对</span><span class="n">t调用右旋</span> <span class="c1">// 其余同理
</span></span></span><span class="line"><span class="cl"><span class="c1">// right rotation. (for LL-insert style)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">rotateWithLeftChild</span><span class="p">(</span> <span class="n">AvlNode</span> <span class="o">*</span> <span class="o">&amp;</span> <span class="n">k2</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">AvlNode</span> <span class="o">*</span><span class="n">k1</span> <span class="o">=</span> <span class="n">k2</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">k2</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">k1</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">k1</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">k2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// after rotation , update the height.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">k2</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span> <span class="n">height</span><span class="p">(</span> <span class="n">k2</span><span class="o">-&gt;</span><span class="n">left</span> <span class="p">),</span> <span class="n">height</span><span class="p">(</span> <span class="n">k2</span><span class="o">-&gt;</span><span class="n">right</span> <span class="p">)</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">k1</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span> <span class="n">height</span><span class="p">(</span> <span class="n">k1</span><span class="o">-&gt;</span><span class="n">left</span> <span class="p">),</span> <span class="n">k2</span><span class="o">-&gt;</span><span class="n">height</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">k2</span> <span class="o">=</span> <span class="n">k1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// LR-insert.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">doubleWithLeftChild</span><span class="p">(</span> <span class="n">AvlNode</span> <span class="o">*</span> <span class="o">&amp;</span> <span class="n">k3</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">rotateWithRightChild</span><span class="p">(</span> <span class="n">k3</span><span class="o">-&gt;</span><span class="n">left</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">rotateWithLeftChild</span><span class="p">(</span> <span class="n">k3</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>时间复杂度分析</strong></p>
<ul>
<li>计算高度O(logN)；</li>
<li>保证查询O(logN)避免Binary Tree最坏的N；</li>
<li>但由于旋转存在，操作效率低，特别是remove时可能需要一直旋转到根；</li>
<li>额外封装，繁琐。</li>
</ul>
<p><em>另一种写法：独立的balance操作</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// at the end of each insert or remove operation, you need to do &#34;balance(t)&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">ALLOWED_IMBALANCE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">balance</span><span class="p">(</span> <span class="n">AvlNode</span> <span class="o">*</span> <span class="o">&amp;</span> <span class="n">t</span> <span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">t</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">height</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span> <span class="p">)</span> <span class="o">-</span> <span class="n">height</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="n">ALLOWED_IMBALANCE</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">height</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">left</span> <span class="p">)</span> <span class="o">&gt;=</span> <span class="n">height</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">right</span> <span class="p">)</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">      <span class="n">rotateWithLeftChild</span><span class="p">(</span> <span class="n">t</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="k">else</span> 
</span></span><span class="line"><span class="cl">      <span class="n">doubleWithLeftChild</span><span class="p">(</span> <span class="n">t</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="n">height</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span> <span class="p">)</span> <span class="o">-</span> <span class="n">height</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="n">ALLOWED_IMBALANCE</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">height</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">right</span> <span class="p">)</span> <span class="o">&gt;=</span> <span class="n">height</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">left</span> <span class="p">)</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">      <span class="n">rotateWithRightChild</span><span class="p">(</span> <span class="n">t</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">      <span class="n">doubleWithRightChild</span><span class="p">(</span> <span class="n">t</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">t</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span> <span class="n">height</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span> <span class="p">),</span> <span class="n">height</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span> <span class="p">)</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="splay-树" class="headerLink">
    <a href="#splay-%e6%a0%91" class="header-mark"></a>Splay 树*</h4><p>保证从空树开始任意连续M次操作最多花费 $O(MlogN)$ 的时间</p>
<h3 id="traversals" class="headerLink">
    <a href="#traversals" class="header-mark"></a>Traversals</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 前序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">文件路径展开</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 中序 O(N)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span><span class="p">(</span> <span class="n">t</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">printTree</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">out</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">element</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">printTree</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">out</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 后序 O(N)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">高度计算</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 层序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="o">&lt;</span><span class="n">queue</span><span class="o">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="b-树" class="headerLink">
    <a href="#b-%e6%a0%91" class="header-mark"></a>B 树*</h3><h3 id="sets--maps" class="headerLink">
    <a href="#sets--maps" class="header-mark"></a>Sets &amp; Maps</h3><ul>
<li>Sets｜排序、去重</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="c1">//logN
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">a</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="n">a</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="n">a</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Maps｜key-value(&gt;=1)</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// key:b-&gt;first; value:b-&gt;second....
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="哈希" class="headerLink">
    <a href="#%e5%93%88%e5%b8%8c" class="header-mark"></a>哈希</h2><ul>
<li>散列表</li>
<li><code>insert</code> / <code>search</code> / <code>delete</code></li>
<li>average:O(1)</li>
<li>Key -&gt; Table</li>
<li>素数</li>
<li>TableSize</li>
<li>collision</li>
</ul>
<h3 id="分析" class="headerLink">
    <a href="#%e5%88%86%e6%9e%90" class="header-mark"></a>分析</h3><p><strong>负数补偿？</strong></p>
<ul>
<li>value&lt;0，then+tableSize</li>
</ul>
<p><strong>均匀分配键：</strong></p>
<ul>
<li>单元数目有限，键数实际上无穷</li>
<li>习惯：0～tableSize-1</li>
<li>装填因子</li>
<li>分离链接法（缺点：内存分配耗时）</li>
<li>除了链表，也可用二叉树/新散列表</li>
</ul>
<h3 id="开放寻址法" class="headerLink">
    <a href="#%e5%bc%80%e6%94%be%e5%af%bb%e5%9d%80%e6%b3%95" class="header-mark"></a>开放寻址法</h3><ul>
<li>
<p>冲突解决函数，$\lambda&lt;0.5$ 聚集效应, $f(i)$ 为冲突点与探查点的距离</p>
</li>
<li>
<p>线性探测: $f(i)=i$ ；一次聚集-占据单元形成区块</p>
</li>
<li>
<p>平方探测: $f(i)=i^2$ 二次聚集</p>
<p><em>保证表的大小是素数，否则表被填满一半就找不到空单元了</em></p>
</li>
<li>
<p>双散列:f(i)=i*hash(x),结果不可以为0；example，hash(x)=R-(xmodR)</p>
</li>
</ul>
<h3 id="再散列" class="headerLink">
    <a href="#%e5%86%8d%e6%95%a3%e5%88%97" class="header-mark"></a>再散列</h3><ul>
<li>$O(N)$</li>
<li>一半/插满的策略</li>
<li>途中策略：某一装填因子</li>
</ul>
<h3 id="可扩散列" class="headerLink">
    <a href="#%e5%8f%af%e6%89%a9%e6%95%a3%e5%88%97" class="header-mark"></a>可扩散列*</h3><h2 id="priority-queues--heaps" class="headerLink">
    <a href="#priority-queues--heaps" class="header-mark"></a>Priority Queues &amp; Heaps</h2><h3 id="二叉堆" class="headerLink">
    <a href="#%e4%ba%8c%e5%8f%89%e5%a0%86" class="header-mark"></a>二叉堆</h3><ul>
<li>完全二叉树</li>
<li>最小堆、最大堆</li>
<li>数组存储 $i,2i,2i+1$</li>
<li>查找 $O(N)$</li>
<li>堆序性质</li>
</ul>
<p><strong>为何选用Heap？</strong></p>
<ul>
<li>Min/Max: $O(1)$</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span> <span class="k">const</span> <span class="n">Comparable</span> <span class="o">&amp;</span> <span class="n">x</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// check size.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span> <span class="n">currentSize</span> <span class="o">==</span> <span class="n">array</span><span class="p">.</span><span class="n">size</span><span class="p">(</span> <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="n">array</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span> <span class="n">array</span><span class="p">.</span><span class="n">size</span><span class="p">(</span> <span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Percolate up 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">hole</span> <span class="o">=</span> <span class="o">++</span><span class="n">currentSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Comparable</span> <span class="n">copy</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">array</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">copy</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">array</span><span class="p">[</span> <span class="n">hole</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">];</span> <span class="n">hole</span> <span class="o">/=</span> <span class="mi">2</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">array</span><span class="p">[</span> <span class="n">hole</span> <span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">array</span><span class="p">[</span> <span class="n">hole</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">]</span> <span class="p">);</span> <span class="c1">// 规避大量交换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">array</span><span class="p">[</span> <span class="n">hole</span> <span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">array</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="applications-of-priority-queues" class="headerLink">
    <a href="#applications-of-priority-queues" class="header-mark"></a>Applications of Priority Queues</h3><h2 id="排序" class="headerLink">
    <a href="#%e6%8e%92%e5%ba%8f" class="header-mark"></a>排序</h2><h3 id="插入排序" class="headerLink">
    <a href="#%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f" class="header-mark"></a>插入排序</h3><h3 id="快排" class="headerLink">
    <a href="#%e5%bf%ab%e6%8e%92" class="header-mark"></a>快排</h3><h4 id="pivot策略" class="headerLink">
    <a href="#pivot%e7%ad%96%e7%95%a5" class="header-mark"></a>Pivot策略</h4><p><strong>最好/坏可能性</strong></p>
<ul>
<li>随机选择待排序序列中的一个数字作为划分字问题的标准，划分是否平均影响算法复杂度</li>
<li>每次问题规模减半，$a=2，b=2，d=1$</li>
<li>复杂度为 $n^2 log(n)$</li>
<li>最差情况下，复杂度为 $O(n^2)$</li>
</ul>
<h4 id="选择的线性期望时间算法" class="headerLink">
    <a href="#%e9%80%89%e6%8b%a9%e7%9a%84%e7%ba%bf%e6%80%a7%e6%9c%9f%e6%9c%9b%e6%97%b6%e9%97%b4%e7%ae%97%e6%b3%95" class="header-mark"></a>选择的线性期望时间算法</h4><h3 id="线性时间排序-bucket-sort-and-radix-sort-复杂度分析" class="headerLink">
    <a href="#%e7%ba%bf%e6%80%a7%e6%97%b6%e9%97%b4%e6%8e%92%e5%ba%8f-bucket-sort-and-radix-sort-%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90" class="header-mark"></a>线性时间排序: Bucket Sort and Radix Sort 复杂度分析</h3><h3 id="计基数排序非比较算法" class="headerLink">
    <a href="#%e8%ae%a1%e5%9f%ba%e6%95%b0%e6%8e%92%e5%ba%8f%e9%9d%9e%e6%af%94%e8%be%83%e7%ae%97%e6%b3%95" class="header-mark"></a>计（基）数排序——非比较算法</h3><ul>
<li>对于待排序的整数序列，从最低位到最高位每次按照相应的位排序一次</li>
<li>每次递归问题规模变为原来的1/10，但需要求解10个子问题，额外运算为 $O(n)$ 的，$a=10，b=10，d=1$</li>
<li>复杂度为 $n^1 log(n) = nlog(n)$ ，近似为 $O(kN)$ ，k为整数的位数</li>
</ul>
<h3 id="归并排序堆排序" class="headerLink">
    <a href="#%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f%e5%a0%86%e6%8e%92%e5%ba%8f" class="header-mark"></a>归并排序/堆排序</h3><p>归并排序</p>
<ul>
<li>数据列均分为两部分，分别排序，之后以 $O(n)$ 的复杂度进行合并，空间复杂度 $O(n)$</li>
<li>每次问题规模减半，$a=2，b=2，d=1$</li>
<li>复杂度为 $nlog(n)$</li>
</ul>
<h2 id="图论" class="headerLink">
    <a href="#%e5%9b%be%e8%ae%ba" class="header-mark"></a>图论</h2><ul>
<li>G[graph] -&gt; V[vertex]</li>
<li>E[edge(arc)], path</li>
<li>digraph 有向</li>
<li>Weight&amp;cost 权/值</li>
<li>Adjacent 邻接</li>
<li>cycle 回路：满足 $w1=wN$ , length&gt;=1</li>
<li>loop 环：回到自身，length=0</li>
<li>Simple path 简单路径</li>
<li>强/弱连通、基础图/完全图</li>
</ul>
<h3 id="表示" class="headerLink">
    <a href="#%e8%a1%a8%e7%a4%ba" class="header-mark"></a>表示</h3><ul>
<li>Adjacent Matrix：dense <code>A[u][v]</code></li>
<li>Adjacent List：sparse $O(|E|+|V|) $</li>
</ul>
<h3 id="拓扑排序" class="headerLink">
    <a href="#%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f" class="header-mark"></a>拓扑排序</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-&gt; delete v1, neighbors indegree-1 
</span></span><span class="line"><span class="cl">-&gt; find indegree=0 v2
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>$O(V^2)$ using <code>&lt;Queue&gt;</code></li>
</ul>
<h3 id="dijkstras" class="headerLink">
    <a href="#dijkstras" class="header-mark"></a>Dijkstras</h3><h3 id="最坏可能" class="headerLink">
    <a href="#%e6%9c%80%e5%9d%8f%e5%8f%af%e8%83%bd" class="header-mark"></a>最坏可能</h3><h3 id="可对负边权使用的算法" class="headerLink">
    <a href="#%e5%8f%af%e5%af%b9%e8%b4%9f%e8%be%b9%e6%9d%83%e4%bd%bf%e7%94%a8%e7%9a%84%e7%ae%97%e6%b3%95" class="header-mark"></a>可对负边权使用的算法</h3><h3 id="最小生成树" class="headerLink">
    <a href="#%e6%9c%80%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91" class="header-mark"></a>最小生成树</h3><ul>
<li>如何扩张？（Ch10）</li>
</ul>
<h3 id="深度优先-广度优先" class="headerLink">
    <a href="#%e6%b7%b1%e5%ba%a6%e4%bc%98%e5%85%88-%e5%b9%bf%e5%ba%a6%e4%bc%98%e5%85%88" class="header-mark"></a>深度优先 广度优先</h3><h2 id="算法设计补充" class="headerLink">
    <a href="#%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1%e8%a1%a5%e5%85%85" class="header-mark"></a>算法设计补充</h2><h3 id="贪心算法" class="headerLink">
    <a href="#%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95" class="header-mark"></a>贪心算法</h3><ul>
<li>ch10.1 分析复杂度</li>
</ul>
<h3 id="分治算法-divide-and-conquer" class="headerLink">
    <a href="#%e5%88%86%e6%b2%bb%e7%ae%97%e6%b3%95-divide-and-conquer" class="header-mark"></a>分治算法 Divide-and-Conquer</h3><ul>
<li>分而治之，递归</li>
</ul>
<h3 id="dynamic-programming" class="headerLink">
    <a href="#dynamic-programming" class="header-mark"></a>Dynamic Programming</h3><ul>
<li>ch10.3 与d-c的比较（自底向上&amp;自顶向下）</li>
</ul>
<h3 id="回溯法" class="headerLink">
    <a href="#%e5%9b%9e%e6%ba%af%e6%b3%95" class="header-mark"></a>回溯法</h3>]]></description>
</item><item>
    <title>时代、经典与她的叙事</title>
    <link>https://blog.ralvines.top/wxqy/</link>
    <pubDate>Tue, 30 Mar 2021 20:20:40 &#43;0800</pubDate><author>
                        <name>Ralvine</name><uri>https://blog.ralvines.top/about/praise/</uri><email>ralvine@163.com</email></author><guid>https://blog.ralvines.top/wxqy/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://z1.ax1x.com/2023/10/23/piAW5eH.png" referrerpolicy="no-referrer">
            </div><h2 id="名词解释" class="headerLink">
    <a href="#%e5%90%8d%e8%af%8d%e8%a7%a3%e9%87%8a" class="header-mark"></a>名词解释</h2><ul>
<li>
<p>三红一创，青山保林：指的是对新中国十七年小说的坚持政治艺术统一的高度概括，也是十七年红色经典小说的高度集中。毛泽东文艺思想《在延安文艺座谈会上的讲话》在1949年后逐渐成为指导全国文学艺术工作的唯一正确的文艺思想。这时期的文艺路线是：文学为政治服务，文学为工农兵服务。文学别无选择的充当了生活教科书的任务。</p>
</li>
<li>
<p>范式：范式从本质上讲是一种理论体系、理论框架。在该体系框架之内的该范式的理论、法则、定律都被人们普遍接受。</p>
</li>
<li>
<p>撰论：金庸社论？</p>
</li>
<li>
<p>超验：超出一切可能的经验之上，超越时间、空间等存在形式，不能用因果、属性、存在、不存在等范畴进行思考的东西。强调直觉，超越感觉理性。</p>
</li>
<li>
<p>暴力美学：暴力美学主要是在感官上，使暴力以美学的方式呈现，诗意的画面，甚至幻想中的镜头来表现人性暴力面和暴力行为。观赏者本身往往惊叹于艺术化的表现形式，无法对内容产生具体的不舒适感。</p>
</li>
<li>
<p>伟人生活化模式、政治人格化模式、社会心理化模式。</p>
</li>
<li>
<p>社会学意义的80后：家庭结构、伦理观念、经济结构、人与物关系、当代中国历史和技术环境的变化。</p>
</li>
<li>
<p>80后作家：(2010年前80后作家群概念扩展而来) 指1980年后出生的一些作家写手，互联网写作环境对他们影响深刻，创作初期主要以同龄人为阅读对象。萌芽作家和非萌芽作家。体制外写作和第二渠道发行。娱乐原则和交换原则下的大众传媒的扩张。</p>
</li>
<li>
<p>第二渠道：二渠道是指除主渠道(传统国营书店如新华书店等)以外的其他发行渠道，主要是民营的图书批发和零售通道。还有“特殊渠道”指网上书店、系统发行等新兴发行渠道。</p>
</li>
<li>
<p>唯理性教学模式：将充满人性之美和生活趣味的语文变成机械枯燥的应试训练。“唯理性教学模式”纵横贯穿于语文教学领域。这种模式崇尚抽象、概括、提炼、崇尚逻辑思维能力，却忽略情感、意志和审美情趣的介入；重视将一切语文知识加以解构和量化，却忽略了从文本和人本的整体角度高屋建瓴地培养学生的语文能力；重视语文学科的互补性。</p>
</li>
<li>
<p>50后到90后：建构大历史，解构，生活，虚拟，无视社会-自我，群体-小我，大众-私我，世界-亲我。</p>
</li>
<li>
<p>80后风格：现代生活，速度生活，都市风情、酒吧咖啡商场职场等文化、国际化视角、叛逆与自我立场。</p>
</li>
<li>
<p>耽美文学：耽美一词最早是出现在日本近代文学中，为反对“自然主义”文学而呈现的另一种文学写作风格。有“耽美派”，它的最初本意是反对以暴露人性的丑恶面为主的自然主义，并想找出官能美、陶醉其中追求文学的意义。引申为代指一切美形的男性，以及男性与男性之间不涉及繁殖的恋爱感情，最后更发展为同性恋漫画的代称之一。</p>
</li>
<li>
<p>同人小说：指的是利用原有的漫画、动画、小说、影视作品中的人物角色、故事情节或背景设定等元素进行的二次创作小说。同人小说一般是以网络小说为载体，近年来，伴随体育人物、娱乐人物、政治人物等社会人物的高密集度曝光，同人小说中的真人同人小说也逐渐兴起。</p>
</li>
<li>
<p>韩寒：创作原则现实主义、文学反映人生的传统文学观念、讽喻，批判、叛逆、个性化表达，社会游荡者流浪者傻傻的同行者纯情女友人物形象，松散离奇骑士情结滑稽人生经历，反讽夸大双关荒诞。</p>
</li>
<li>
<p>80后电影：青春成长题材，情感与成长阵痛，独立电影影像表达，梦幻暴力场面，较强的影响语言把握运用能力。</p>
</li>
<li>
<p>生态文学：关于生态问题的文学，具有生态维度的文学，反思和批判生态思想和观念表达，基于当下和现实生态状况的文学作品，具有生态标准或尺度的文学创作和批评。揭示问题，试图摆脱危机。</p>
</li>
<li>
<p>生态危机：整体而非局部的生态系统出现问题，被破坏。人类文明历史是一部人类与自然的关系史</p>
</li>
<li>
<p>人类中心主义：又译“人类中心论”，是以人类为事物的中心的学说。同其他文化观念一样，人类中心主义的观念也具有历史发展的连续性和间断性，这一概念曾在三个意义上使用人类中心主义总是作为一种价值和价值尺度而被采用的，把人类的利益作为价值原点和道德评价的依据，有且只有人类才是价值判断的主体。</p>
</li>
<li>
<p>土地伦理：土地伦理是环境伦理的视角之一，是由奥尔多·利奥波德在他的《沙乡年鉴》一书中首次倡导的。其中他写道，需要一种“新的伦理”，“一种处理人与土地，以及人与在土地上生长的动物和植物之间的伦理观”。在他那个时代，美国林业局的主流观念从创立者吉福德·平肖开始，就是追求经济利益的和功利主义的，而利奥波德则主张一种“生态学”的态度(这个词由芝加哥大学的亨利·钱德勒·考尔斯于20世纪初在对印地安那沙丘的研究中提出，利奥波德是该术语最早的推广者之一)。资源保护主义在更偏向人类中心主义的资源管理范式中获得了它的首要地位，而与此同时，利奥波德的著作和启发与约翰·缪尔一起引发了环境主义的发展。</p>
</li>
<li>
<p>生态文学价值取向：否定强权、人类中心主义重构人和自然关系，同情关怀弱势种群探寻非人类种群精神世界，坚持开放评判姿态倡导土地伦理以孩童或他者视角，强调人类责任探寻生态危机原因预测世界未来。</p>
</li>
<li>
<p>景别：景别是指由于在焦距一定时，摄影机与被摄体的距离不同，而造成被摄体在摄影机录像器中所呈现出的范围大小的区别。景别的划分，一般可分为五种，由近至远分别为特写(指人体肩部以上)、近景(指人体胸部以上)、中景(指人体膝部以上)、全景(人体的全部和周围部分环境)、远景(被摄体所处环境)。</p>
</li>
<li>
<p>镜头语言：镜头语言就是用镜头像语言一样去表达我们的意思，我们通常可经由摄影机所拍摄出来的画面看出拍摄者的意图，因为可从它拍摄的主题及画面的变化，去感受拍摄者透过镜头所要表达的内容。</p>
</li>
<li>
<p>女性意识与南方文化：江南经济发展带来新的时尚，经济发展带来坊刻文化繁荣，文字图画共存产生新欣赏口味满足情感需求</p>
</li>
<li>
<p>女性作家群：闺塾师，妇女诗社。</p>
</li>
<li>
<p>女性文学规模形成：情趣化和美感合理运用冲破科场文化限制，产生新文类新空间。至此成为被拘囿和局限了空间和观念的充满通融和争执的存在。</p>
</li>
<li>
<p>传统女性文学：零星存在的才女创作，文以载道成为中国文学核心价值，教育资源性别倾斜。特点：女性只能通过男性角色完成心愿才能展示，女性意识表现不能超越社会价值观念，女性意识只能委婉曲折地得以传达传统和新女性文学的审美表达、文类、视角区别：国事政事到家事情事，优美与壮美，亚文类诗-词，史传-小说。</p>
</li>
<li>
<p>亚文类：从属于&hellip;&hellip;</p>
</li>
<li>
<p>科场：科举场所·五四女性文学：批家庭家族文化反抗父权表达爱情个人反抗夫权，女教师学生形象，如萧红、丁玲、白薇。</p>
</li>
<li>
<p>三四十年代女性文学：彼时女性普遍生存现实的书写、生命意识和精神世界的探索，如丁玲、萧红、张爱玲</p>
</li>
</ul>
<h2 id="3月11日---时代与经典的关系" class="headerLink">
    <a href="#3%e6%9c%8811%e6%97%a5---%e6%97%b6%e4%bb%a3%e4%b8%8e%e7%bb%8f%e5%85%b8%e7%9a%84%e5%85%b3%e7%b3%bb" class="header-mark"></a>3月11日 - 时代与经典的关系</h2><p>作为裹挟于时代浪潮之中的个体，我们很难不受到一定时期社会经济基础、主流意识形态及生活方式的影响，也自然难以超脱于一定的历史桎梏。</p>
<p>譬如春秋战国时期松散的权力结构和相对适足的经济基础营造出一段思想多元的历史浪潮，诸子百家各自收揽大批追随者。而在秦代之后的君主专制中央集权时期，帝王及其朝廷所采取的治理模式很大程度上影响到社会的主流思潮，因而，生前郁郁不得志的孔子也难以预料到罢黜百家后的中原王朝将在千年的历史长河中将儒家经典奉为圭臬。</p>
<p>诗歌、书法形式的变革亦如是，而伴随着市井文化和较为稳定社会环境下的新兴商贸体系的形成、社会生活的日益丰富和各阶层群体利益的复杂化，明清文人又将主流视角从曾经强调主观情调与高洁理想的抒情范式转向了更多强调矛盾与故事性的长篇小说与戏曲。</p>
<p>而对于《青春之歌》来说，我认为它的现实意义在于其以爱情主线展现出时代变迁中的社会主流意识形态演化脉络及沉浮其中的小人物的精神蜕变，而前者恰恰属于对青春主题所作出的极富那个年代历史语境下的价值解构。</p>
<p>如前所述，随着时代的变革，传统社会形态和价值取向的消解，自然优先作用于文艺创作的土壤。建国前期，传统氏族结构的崩溃和产缘纽带的建构加速歧化社会群体生活理念之于以高级知识分子代表的精英与广泛的劳动大众的落差。而五四以降，特别是以左翼革命为主线的元叙事成为中国社会意识形态的中流砥柱之后，民国早期以引入、吸收、传播乃至照搬西方启蒙思想的文人群体与“农村包围城市”的无产阶级觉醒产生了精英与平民视角的对立。在新民主主义革命者在天安门城楼宣布胜利的历史帷幕之下，主流话语体系自然如毛泽东文艺思想所展现——强调“人民性”与“革命性”，对“高高在上”教化愚昧无知大众的旧知识分子群体赋予了批判和改造的内在使命，而这恰恰寓于彼时文学作品的内核之中。正如林道静爱情主线下的身份转变，从资产阶级知识分子到无产阶级革命者，从同余永泽相处时之于革命较为纯粹的浪漫主义和理想主义到最后彻底脱离旧体系束缚、成为更为独立坚毅的女性共产主义战士，极具彼时时代特征的宏大思想理念作为政治隐喻内化于情感叙事之中，对于当代的我们理解这一历史阶段具有生动的意义。</p>
<h2 id="3月18日---金庸小说的意义与影响" class="headerLink">
    <a href="#3%e6%9c%8818%e6%97%a5---%e9%87%91%e5%ba%b8%e5%b0%8f%e8%af%b4%e7%9a%84%e6%84%8f%e4%b9%89%e4%b8%8e%e5%bd%b1%e5%93%8d" class="header-mark"></a>3月18日 - 金庸小说的意义与影响</h2><p>金庸的武侠作品在我们这一代人的青年时段中似乎正在悄然式微，相较文学本身，留给我们的更多的往往是电视上《射雕英雄传》《天龙八部》的浮光掠影。因此，当我们提到金庸武侠小说的影响时，必然绕不开它和它贯穿的整个文学时代给现在的我们留下了什么。
首先，金庸的武侠小说开启了此类文学作品的全新范式。在当今许多新兴网络文学作品中，那些英雄、玄幻色彩背后，往往蕴含着金庸时代武侠小说的叙事风格和情节架构。古代传统社会的背景下，具有现代主义特征的爱情、仁善元素包裹着其特有的畅快淋漓之词藻，将打斗场面描绘得无比生动。阅读时，我能感受到它与读者偌大想象空间的完美契合。
其次，金庸的武侠小说影响了一代人，特别是在世界观的形成层面。“侠之大者，为国为民。”相较于《水浒》等古代经典小说，金庸文学作品更突出救死扶伤、保家卫国、同情弱者的人文关怀，这与他创作时的时代背景是密不可分的。它不仅仅强调传统的忠义兄弟情，更展现了人性的复杂一面。即便是江湖英雄，也有脆弱的一面；如此仗义的侠客，也总有种种缺点和软肋。而善恶亦不是纯粹的二元对立，大量“圆形人物”的塑造往往透露出老庄辩证哲学的转化思想。正所谓“有人的地方就有江湖”，金庸作品似乎善于解构正义与邪恶对立背后的复杂利益因素，在人情世故中将丰富的感性成分融入于前者。</p>
<h2 id="5月27日---80后文学的时代风格" class="headerLink">
    <a href="#5%e6%9c%8827%e6%97%a5---80%e5%90%8e%e6%96%87%e5%ad%a6%e7%9a%84%e6%97%b6%e4%bb%a3%e9%a3%8e%e6%a0%bc" class="header-mark"></a>5月27日 - 80后文学的时代风格</h2><p>或许因为代际差异，个人对80后作家的文学作品并不是很熟悉。就80后文学作品的风格、选材及作者审美诉求的变化，正如此前数周大家所呈现和讨论，“计划生育”、改革开放、外来文化冲击、互联网萌芽、去政治化等等要素建构了这一代人的集体意识形态。这一点也在伤痕文学中有所体现。</p>
<p>80后作家们的视角更趋向“小我”，在各种新鲜事物或文化的强烈冲击之下，80后有一种置于承前启后时代的独特孤独感，一方面受到社会传统领域的束缚牵制，另一方面到处孕育着多元的机会。我想这注定是彷徨、探索着的一代，具体来说，《上海公园》中同学聚会上大量对白的表达所呼应的悲伤、压抑的意象，正是这一代人冲动而迷茫的缩影。那些旧日同窗有的谈吐中时刻夹杂着外语，眼神里显现出无尽的却又有些幼稚的渴望与追求感；有的弹奏吉他，沉醉于自我的表达，也奋力于谋求出路……总而言之，是对宏大叙事的回避，是对小我情态的捕捉，贯穿其中、处处可见的则是都市、西方文化与懵懂青年的朦胧交错。</p>
<h2 id="6月10日---生态文学叙事" class="headerLink">
    <a href="#6%e6%9c%8810%e6%97%a5---%e7%94%9f%e6%80%81%e6%96%87%e5%ad%a6%e5%8f%99%e4%ba%8b" class="header-mark"></a>6月10日 - 生态文学叙事</h2><p>冷峻而真实的场景建构、人性与生命脆弱性的呈现似乎是《可可西里》代表的这一类生态影片的叙事共性。在生命的禁区，善恶界限愈发模糊、道德伦理与法律秩序渐隐，刘栋和日泰的突然死亡深刻地揭示了人类在自然面前的渺小，而日泰不得不卖皮子与马占林复杂的人物形象体现着上述生存遇到威胁的情境下现实之于个体的矛盾。在某种意义上说，在当下人与自然的和谐共生本质上仍然是人类基于自身主观利益的诉求，当自然反噬人类的侵略行为或是人类惊觉自然资源的稀缺性时，其才展现出可悲的保护意识；人类的理性往往屈从于求生的基础本能，这是一种妥协与无奈，也振聋发聩地促使我们去反思，我们究竟需要追求一种怎样的同自然生态的交互反馈。</p>
<p>课后随想：本次讨论课的主题是生态文学，并比较分析了《狼图腾》和《怀念狼》两部作品。命题的核心如老师在周二课上提出，生态文学是“退步的文学”，是人类文学发展进程中的一次“回眸”。要理解生态文学，自然需要聚焦于其意识产生的基础，即人类发展中“进步的模式”同“文明的模式”之间存在的必然的矛盾及人改造、征服自然过程中受到反噬从而产生的问题。而从文学角度讲，生态文学所要反思的本质上是社会生态、精神生态的问题，探讨人类自身在相应认知上存在的问题。由此而言，生态文学无疑是对客观现实的一种进步反映，也是人类在工业化浪潮下环保意识、天人合一意识的觉醒。然而，这一时期的生态文学又有一种人类生活模式的保守化倾向，毕竟在工业化对自然显著的、触目惊心的破坏现实之中，文学创作者们又难以找到一条清晰的解决路径，从而容易陷入到“返璞归真”的思维陷阱之中。无论如何，发展的问题恐怕只能用发展解决，我认为人类应当顺应生产力发展的方向，通过科技的进步为人与自然和谐共生提供强力的正反馈。</p>
<h2 id="6月17日---文艺作品中的女性角色" class="headerLink">
    <a href="#6%e6%9c%8817%e6%97%a5---%e6%96%87%e8%89%ba%e4%bd%9c%e5%93%81%e4%b8%ad%e7%9a%84%e5%a5%b3%e6%80%a7%e8%a7%92%e8%89%b2" class="header-mark"></a>6月17日 - 文艺作品中的女性角色</h2><p>倾向于认为这是一个伪命题。</p>
<p>当代对女性群体的关注与女性这一群体概念的强化本身是平权主义的分支，也就是消除传统桎梏尚未完全解体的性别歧视与刻板印象。然而，刚才当我们谈论这些性别标签下的群体特质时，却恰恰是在潜移默化地在制造刻板印象。</p>
<p>但是它为什么存在？课堂上有同学提到的铁娘子撒切尔夫人，这一套“强硬”形象难道就是男性固有的特质吗？我更相信这是一种文化惯性的结果，是传统男性主导地位导致的。比如过去的领导人绝大部分都是男性，既有文质彬彬儒雅随和者、也有政治强人、强硬做派者，凡此种种，其实本质上是群体的历史记忆让在过去占有主导地位的男性垄断了绝大部分特质的标签。</p>
<p>而对于所谓的性别视角下作家的思维特质，我认为这其实属于个体化的范畴，而非由性别因素所决定。譬如同为男性作家，木心和刘慈欣拥有着迥然不同的创作风格与叙事模式。这些实质上是作者在职业、文化氛围、生活环境、宗教、思维模式乃至意识形态上的差别，而思维模式等要素本身很少受到性别本身的影响。
值得一提的是，从生物学上说，男女之间的基因演化最终是趋同的，男性与女性不同基因对其认知与行为模式差异的影响远远小于外在环境等因素。</p>
<p>个人认为，当代女权主义中的反抗精神仿佛是一种“弱势者的群体皈依，抱团取暖”的表现，这自然有一定的道理，然而也不能忽视事实上掌握话语权的核心并非性别。如当代西方普遍的种族问题，往往掩盖了根本的阶级矛盾；又比如80后的标签，是这一代人在改革开放浪潮、独生子女政策等集体记忆和社会背景下交互下的产物，而不能简单归咎于在80年代出生这一基本定义。</p>
<p>至于性别话语权的垄断确实存在，但在当代更多地是表现在刻板印象之中，比如所谓的男性阳刚女性阴柔，以及女性生理特质带来的部分劣势之中，比如由于生育、产假、体力问题导致的女性在职场中的弱势地位，不过不要忽视此种差异是双向的，正如随着社会发展，尽管简单的体力工作男性占据了主体优势，却也有一些专属于女性的职业存在。</p>
<p>课上谈论女性悲剧形象时，就有不少同学指出去除性别标签后，悲剧的形象仍然有着共性。而女性文学中普遍提到的封建社会下如翠翠独守闺房与祥林嫂式的悲剧，前者是女性在生活上的依附现实，后者则是生产上的性别依附。</p>
<p>总体来说，此种话语权的不匹配在现代社会下是在不断消解的。我比较认同平权问题用辩证唯物主义那套理论框架来阐释，当代妇女解放与女性意识的觉醒本身就是在后工业化时代，社会生产关系中的性别差异被机器的运用所逐渐抹平，女性大规模参与到现代生产活动之中的结果。</p>
<p>男女的差异事实上主要仍然体现在基因等生理要素之上，当代很多性别不平等现象相较封建时代已经得到了很大的进步，相反，很多问题是文化惯性、历史遗留，这在生产力落后的农村和欠发达地区仍有呈现。我们知道即便是在原始社会也存在着母系社会，所谓的父权社会很大程度上是战争频繁的农耕时代男性由于生理上具有的体力优势的社会经济基础所衍生出的一套伦理体系。而这些差异已经被证明是能够随着科技进步而式微的，因此，对于“女性的悲剧结局能否避免”这一论题，我相信这将随着时代的发展获得肯定的答案。</p>]]></description>
</item></channel>
</rss>
