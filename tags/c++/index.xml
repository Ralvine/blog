<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>C&#43;&#43; - 标签 - 暮瞻</title>
        <link>https://blog.ralvines.top/tags/c&#43;&#43;/</link>
        <description>C&#43;&#43; - 标签 - 暮瞻</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 12 Oct 2023 13:20:40 &#43;0800</lastBuildDate><atom:link href="https://blog.ralvines.top/tags/c&#43;&#43;/" rel="self" type="application/rss+xml" /><item>
    <title>华为：鸿蒙通用软件开发复盘</title>
    <link>https://blog.ralvines.top/huawei/</link>
    <pubDate>Thu, 12 Oct 2023 13:20:40 &#43;0800</pubDate><author>
                        <name>Ralvine</name><uri>https://blog.ralvines.top/about/praise/</uri><email>ralvine@163.com</email></author><guid>https://blog.ralvines.top/huawei/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://z1.ax1x.com/2023/10/24/piEGg5n.jpg" referrerpolicy="no-referrer">
            </div><h2 id="岗位信息" class="headerLink">
    <a href="#%e5%b2%97%e4%bd%8d%e4%bf%a1%e6%81%af" class="header-mark"></a>岗位信息</h2><p>[基本要求]</p>
<ol>
<li>计算机、软件、通信等相关专业本科及以上学历；</li>
<li>热爱编程，基础扎实，熟悉掌握但不限于JAVA/C++/C/Python/JS/HTML/GO等编程语言中的一种或数种，有良好的编程习惯；</li>
<li>具备独立工作能力和解决问题的能力、善于沟通，乐于合作，热衷新技术，善于总结分享，喜欢动手实践；</li>
<li>对数据结构、算法有一定了解；</li>
</ol>
<p>[优选条件]</p>
<ol>
<li>熟悉TCP/IP协议及互联网常见应用和协议的原理；</li>
<li>有IT应用软件、互联网软件、IOS/安卓等相关产品开发经验，不满足于课堂所学，在校期间积极参加校内外软件编程大赛或积极参于编程开源社区组织；</li>
<li>熟悉JS/AS/AJAX/HTML5/CSS等前端开发技术。</li>
</ol>
<ul>
<li>华为终端BG 软件部 Harmony 手机软件业务</li>
<li>Base上海</li>
</ul>
<h2 id="投递" class="headerLink">
    <a href="#%e6%8a%95%e9%80%92" class="header-mark"></a>投递</h2><h3 id="流程" class="headerLink">
    <a href="#%e6%b5%81%e7%a8%8b" class="header-mark"></a>流程</h3><pre class="mermaid">gantt
    dateFormat  YYYY-MM-DD
    title 华为 终端BG 软件部 Harmony手机上层开发方向 Base上海
    section 通用软件开发工程师
    投递:done,2023-08-09,2023-09-17
    机考:done,2023-09-27, 1d
    综合测评:done,2023-09-28,2023-10-05
    一面,二面,主管面:active,2023-10-12,1d

</pre>
<h3 id="渠道" class="headerLink">
    <a href="#%e6%b8%a0%e9%81%93" class="header-mark"></a>渠道</h3><ul>
<li>华为招聘官方网站</li>
</ul>
<h3 id="面试" class="headerLink">
    <a href="#%e9%9d%a2%e8%af%95" class="header-mark"></a>面试</h3><h4 id="内容回顾" class="headerLink">
    <a href="#%e5%86%85%e5%ae%b9%e5%9b%9e%e9%a1%be" class="header-mark"></a>内容回顾</h4><p><strong>一面</strong></p>
<ol>
<li>自我介绍和简历项目深挖</li>
<li>机考题目回顾和思路陈述</li>
<li>手撕代码</li>
</ol>
<p><strong>二面</strong></p>
<ol>
<li>自我介绍和简历项目深挖</li>
<li>手撕代码</li>
</ol>
<p><strong>主管面</strong></p>
<ol>
<li>自我介绍和个人特质</li>
<li>职业规划和对华为、行业的理解</li>
</ol>
<h2 id="附面经整理" class="headerLink">
    <a href="#%e9%99%84%e9%9d%a2%e7%bb%8f%e6%95%b4%e7%90%86" class="header-mark"></a>附：面经整理</h2>

    <div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>面试经验整理<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p><strong>一面&amp;二面</strong></p>
<ul>
<li>自我介绍
<ul>
<li>准备自我介绍时候最好说些自己熟悉的领域</li>
</ul>
</li>
<li>详细讲项目 细节</li>
<li>笔试复盘
<ul>
<li>思路</li>
</ul>
</li>
<li>手撕代码
<ul>
<li>一个二维数组初始值为0给其中两个点初始值为1每个为1的点每一轮可以上下左右把为0的点转化为1问要几轮将整个二维数组用1填满check1point3acresformore直接想到用队列结合dfs写完面试就结束了总体感觉不难可能是部门缺人降低了bar</li>
</ul>
</li>
<li>基础知识 &amp; 实际应用场景
<ul>
<li>数据结构
<ul>
<li>链表</li>
<li>数组</li>
<li>树</li>
<li>快排</li>
<li>归并排序</li>
<li>哈希</li>
<li>复杂度</li>
<li>图</li>
</ul>
</li>
<li>网络
<ul>
<li>TCP/IP</li>
<li>握手为什么不是两次 为什么不是4次</li>
<li>IP传输是否可靠</li>
<li>局部变量在内存的位置</li>
<li>DFS实际操作中有什么不好</li>
</ul>
</li>
<li>操作系统
<ul>
<li>进程 线程</li>
<li>Linux</li>
</ul>
</li>
<li>C++ 面向对象</li>
<li>MySQL</li>
</ul>
</li>
<li><strong>思维</strong></li>
</ul>
<p><strong>业务主管面试</strong></p>
<ul>
<li>自我介绍</li>
<li>项目</li>
<li>为什么想来华为</li>
<li>压力最大的一件事</li>
<li>什么时候开始学习互联网相关的知识</li>
<li>对加班的看法？如果工作量大怎么办？</li>
<li>为什么选择杭研所？（其实我没有硬性的要求，我都不知道自己面的杭研所）</li>
</ul>
</div>
        </div>
    </div>]]></description>
</item><item>
    <title>C&#43;&#43; 面向对象之面试与机考技巧</title>
    <link>https://blog.ralvines.top/c-interview/</link>
    <pubDate>Wed, 30 Aug 2023 20:20:40 &#43;0800</pubDate><author>
                        <name>Ralvine</name><uri>https://blog.ralvines.top/about/praise/</uri><email>ralvine@163.com</email></author><guid>https://blog.ralvines.top/c-interview/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://z1.ax1x.com/2023/11/01/pinHqnH.png" referrerpolicy="no-referrer">
            </div><h2 id="笔试技巧" class="headerLink">
    <a href="#%e7%ac%94%e8%af%95%e6%8a%80%e5%b7%a7" class="header-mark"></a>笔试技巧</h2><ol>
<li>
<p>输入输出</p>
<ul>
<li>带空格 getline</li>
<li>字符串处理 string</li>
<li>大小写转换
<ul>
<li>string: <code>&lt;algorithm&gt;</code> <code>transform(str.begin(),str.end(),str.begin(),::tolower);</code></li>
<li>char: <code>-'a'+'A'</code></li>
</ul>
</li>
<li>进制转换
<ul>
<li><code>bitset</code></li>
<li>8(oct), 10(dec), 16(hex), 2(bitset(num))</li>
</ul>
</li>
<li>取整 (int)直接去除小数点后的部分</li>
</ul>
</li>
<li>
<p>排序 sort 默认升序 自定义规则</p>
<ul>
<li><code>functional greater&lt;Type&gt;</code></li>
</ul>
</li>
<li>
<p>质数 因数分解</p>
<ul>
<li>时间复杂度 先判断n不是素数再进入计算循环</li>
<li>分解到sqrt(n) 剩下的留n即可</li>
</ul>
</li>
</ol>
<h2 id="经典面试题" class="headerLink">
    <a href="#%e7%bb%8f%e5%85%b8%e9%9d%a2%e8%af%95%e9%a2%98" class="header-mark"></a>经典面试题</h2><h3 id="newdelete和mallocfree的区别" class="headerLink">
    <a href="#newdelete%e5%92%8cmallocfree%e7%9a%84%e5%8c%ba%e5%88%ab" class="header-mark"></a>new/delete和malloc/free的区别</h3><ul>
<li>malloc/free是C/C++的库函数，需要stdlib.h；new/delete是C++的关键字；</li>
<li>都可用于申请动态内存和释放内存，new/delete在对象创建的时候自动执行构造函数，对象消亡前自动执行析构函数，底层实现其实也是malloc/free</li>
<li>new无需指定内存块的大小，编译器会根据类型信息自行计算；malloc需要显式地支持所需内存的大小</li>
<li>new返回<strong>指定类型</strong>的指针，无需进行类型转换；malloc默认返回类型为<strong>void</strong>*，必须强行转换为实际类型的指针</li>
<li>new内存分配失败时会抛出bad_alloc异常；malloc失败时返回NULL</li>
</ul>
<h3 id="malloc的底层实现" class="headerLink">
    <a href="#malloc%e7%9a%84%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0" class="header-mark"></a>malloc的底层实现</h3><p>Linux下：</p>
<ul>
<li>开辟空间小于128K时，通过<strong>brk()函数</strong>
<ul>
<li>将数据段.data的最高地址指针**_edata<strong>向高地址移动，即</strong>增加堆**的有效区域来申请内存空间</li>
<li>brk分配的内存需要等到高地址内存释放以后才能释放，这也是内存碎片产生的原因</li>
</ul>
</li>
<li>开辟空间大于128K时，通过<strong>mmap()函数</strong>
<ul>
<li>利用mmap系统调用，在堆和栈之间<strong>文件映射区域</strong>申请一块虚拟内存</li>
<li>128K限制可由M_MMAP_THRESHOLD选项进行修改</li>
<li>mmap分配的内存可以单独释放</li>
</ul>
</li>
<li>以上只涉及虚拟内存的分配，直到进程第一次访问其地址时，才会通过缺页中断机制分配到物理页中</li>
</ul>
<h3 id="指针和引用的异同点如何相互转换" class="headerLink">
    <a href="#%e6%8c%87%e9%92%88%e5%92%8c%e5%bc%95%e7%94%a8%e7%9a%84%e5%bc%82%e5%90%8c%e7%82%b9%e5%a6%82%e4%bd%95%e7%9b%b8%e4%ba%92%e8%bd%ac%e6%8d%a2" class="header-mark"></a>指针和引用的异同点；如何相互转换</h3><ul>
<li>本质：引用是别名，而指针是地址</li>
<li>指针在运行时可以改变所指向的值，而引用一旦与某个对象绑定之后就不再改变(指向的地址不能改变，但指向的内容可以改变)</li>
<li>指针变量在符号表上对应的地址值为<strong>指针变量的地址值</strong>，而引用在符号表上对应的地址值为<strong>引用对象的地址值</strong>；因此指针可以改变指向的对象，而引用的对象不能修改</li>
<li>由于硬件通过地址访问内存位置，因此引用可以理解为一个常量指针，只能绑定到初始化它的对象上</li>
</ul>
<h3 id="structunion的异同" class="headerLink">
    <a href="#structunion%e7%9a%84%e5%bc%82%e5%90%8c" class="header-mark"></a>struct、union的异同</h3><ul>
<li>struct中每个变量依次存储；union中，每个变量都是从偏移地址零开始存储，同一时刻只有一个成员存储于该地址</li>
<li>struct内存大小遵循<strong>结构对齐</strong>原则
<ul>
<li>数据成员对齐规则：每个数据成员存储的起始位置要从该成员大小的整数倍开始</li>
<li>数据成员包含结构体：结构体成员要从其内部最大元素对象的整数倍地址开始存储</li>
<li>结构体总大小：其内部最大基本成员的整数倍，不足则要补齐</li>
</ul>
</li>
<li>union内存大小为其最大成员的整数倍</li>
</ul>
<h3 id="extern-c的作用" class="headerLink">
    <a href="#extern-c%e7%9a%84%e4%bd%9c%e7%94%a8" class="header-mark"></a>extern C的作用</h3><p>C++支持<strong>函数重载</strong>，即不同名字空间namespace的两个函数原型声明可以完全相同，或者两个函数同名但参数列表不同；g++编译器会对此进行<strong>name mangling</strong>，生成全局唯一的符号名称，使链接器可以准确识别</p>
<p>C语言不支持函数重载，即不允许同名符号，所以不需要这些工作，因此在C++代码中加入extern C，是为了<strong>链接规范</strong></p>
<h3 id="memcpy函数需要注意哪些问题" class="headerLink">
    <a href="#memcpy%e5%87%bd%e6%95%b0%e9%9c%80%e8%a6%81%e6%b3%a8%e6%84%8f%e5%93%aa%e4%ba%9b%e9%97%ae%e9%a2%98" class="header-mark"></a>memcpy()函数需要注意哪些问题</h3><ul>
<li>
<p>函数原型声明void *memcpy(void *dest, void *src, unsigned int count);</p>
</li>
<li>
<p>memcpy函数用于把资源内存（src所指向的内存区域）中连续的count个字节数据拷贝到目标内存（dest所指向的内存区域）</p>
</li>
<li>
<p>数据长度count的单位是字节，1byte = 8bit</p>
</li>
<li>
<p>数据类型为char，则数据长度就等于元素的个数；其他数据类型则要注意数据长度的值</p>
</li>
<li>
<p>n * sizeof(type_name)的写法</p>
</li>
</ul>
<h3 id="strcatstrncatstrcmpstrcpy函数" class="headerLink">
    <a href="#strcatstrncatstrcmpstrcpy%e5%87%bd%e6%95%b0" class="header-mark"></a>strcat、strncat、strcmp、strcpy函数</h3><ul>
<li>strcpy拷贝函数，不会判断拷贝大小，也没有任何安全检查，不会检查目的地址内存是否够用；</li>
<li>strncpy拷贝函数，会计算复制字符串的大小，但没有检查目标的边界；</li>
<li>strcmp比较函数，把src所指向的字符串与dest所指向的字符串进行比较，若dest与src的前n个字符相同，则返回0；若dest大于src，则返回大于0的值；若dest小于src，则返回小于0的值</li>
<li>strcat功能是将两个char类型连接；strncat功能是在字符串的结尾追加n个字符</li>
</ul>
<h3 id="机器大小端问题" class="headerLink">
    <a href="#%e6%9c%ba%e5%99%a8%e5%a4%a7%e5%b0%8f%e7%ab%af%e9%97%ae%e9%a2%98" class="header-mark"></a>机器大小端问题</h3><p>大端指数据的<strong>高字节</strong>保存在内存的<strong>低地址</strong>中，数据的<strong>低字节</strong>保存在内存的<strong>高地址</strong>中；小端与此相反。</p>
<ul>
<li>小端：强制转换数据不需要调整字节内容，1、2、4字节的存储方式一样</li>
<li>大端：符号位的判定固定为第一个字节，很容易判断正负</li>
</ul>
<p>union判断大小端的方法</p>
<ul>
<li>union从低地址开始存，同一时间内只有一个成员占用内存；修改其中一个成员的值必然会影响另一个成员的值</li>
</ul>
<h3 id="static的用法定义和用途" class="headerLink">
    <a href="#static%e7%9a%84%e7%94%a8%e6%b3%95%e5%ae%9a%e4%b9%89%e5%92%8c%e7%94%a8%e9%80%94" class="header-mark"></a>static的用法（定义和用途）</h3><p>修饰</p>
<ul>
<li>局部变量：使其变为<strong>静态存储方式</strong>（静态数据区），函数执行完成之后不会被释放，而是继续保存在内存中；</li>
<li>全局变量：使其只在本文件内部有效，其他文件不可链接或引用该变量；</li>
<li>函数：静态函数，即函数只在本文件内部有效，对其他文件不可见；避免同名干扰，同时保护</li>
</ul>
<h3 id="const的用法定义和用途" class="headerLink">
    <a href="#const%e7%9a%84%e7%94%a8%e6%b3%95%e5%ae%9a%e4%b9%89%e5%92%8c%e7%94%a8%e9%80%94" class="header-mark"></a>const的用法（定义和用途）</h3><p>const起到<strong>强制保护</strong>的修饰作用，可以预防意外改动，提高程序的健壮性</p>
<ul>
<li>const修饰常量：定义时就初始化，以后不能更改；</li>
<li>const修饰形参：func(const int a); 该形参在函数里不能改变；</li>
<li>const修饰类成员函数：const类成员函数不能改变成员变量的数值</li>
</ul>
<h3 id="const常量和define的区别编译阶段安全性内存占用等" class="headerLink">
    <a href="#const%e5%b8%b8%e9%87%8f%e5%92%8cdefine%e7%9a%84%e5%8c%ba%e5%88%ab%e7%bc%96%e8%af%91%e9%98%b6%e6%ae%b5%e5%ae%89%e5%85%a8%e6%80%a7%e5%86%85%e5%ad%98%e5%8d%a0%e7%94%a8%e7%ad%89" class="header-mark"></a>const常量和define的区别（编译阶段、安全性、内存占用等）</h3><ul>
<li>const定义的常量有类型名字，存放在内存的静态区域中，在编译时确定其值；</li>
<li>define定义的常量是没有类型的一个<strong>立即数</strong>，编译器会在预处理阶段将程序中所有使用到该常量的地方进行<strong>拷贝替换</strong>；</li>
<li>由于define的拷贝有很多份，故宏定义的内存占用要高得多</li>
</ul>
<h3 id="volatile的用法" class="headerLink">
    <a href="#volatile%e7%9a%84%e7%94%a8%e6%b3%95" class="header-mark"></a>volatile的用法</h3><p>被定义为volatile的变量可能会被意想不到地改变，编译器不会对volatile变量有关的运算进行<strong>编译优化</strong>：每次使用该变量必须从内存地址中读取，而不是保存在寄存器中的备份</p>
<p>用到volatile的几种情况</p>
<ul>
<li>并行设备的硬件寄存器（如状态寄存器）</li>
<li>中断服务子程序会访问到的非自动变量</li>
<li>多线程应用中被几个任务共享的变量</li>
</ul>
<h3 id="常量指针指针常量常量引用没有引用常量" class="headerLink">
    <a href="#%e5%b8%b8%e9%87%8f%e6%8c%87%e9%92%88%e6%8c%87%e9%92%88%e5%b8%b8%e9%87%8f%e5%b8%b8%e9%87%8f%e5%bc%95%e7%94%a8%e6%b2%a1%e6%9c%89%e5%bc%95%e7%94%a8%e5%b8%b8%e9%87%8f" class="header-mark"></a>常量指针、指针常量、常量引用（没有引用常量）</h3><ul>
<li>常量指针即常量的指针，指针所指向的是个常量，可以被赋值为变量的地址，但是不能通过这个指针来修改</li>
<li>指针常量本质是一个常量，指针所指向的值不可以改变，但指向的地址所对应的内容可以变化</li>
</ul>
<p>（具体参考问题17）</p>
<h3 id="变量的作用域全局变量和局部变量" class="headerLink">
    <a href="#%e5%8f%98%e9%87%8f%e7%9a%84%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e5%92%8c%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f" class="header-mark"></a>变量的作用域（全局变量和局部变量）</h3><ul>
<li>全局变量：在所有函数体外部定义的，程序所在部分都可以使用，不受作用域的影响（生命期一直到程序的结束）</li>
<li>局部变量：局限于作用域内，默认为auto关键字修饰，即进入作用域时自动生成，离开作用域时自动消失；</li>
<li>局部变量可以和全局变量重名，在局部变量作用域范围内，全局变量失效，采用的是局部变量的值</li>
</ul>
<h3 id="sizeof和strlen" class="headerLink">
    <a href="#sizeof%e5%92%8cstrlen" class="header-mark"></a>sizeof和strlen</h3><ul>
<li>sizeof是一个操作符或关键字，不是一个函数，而strlen是一个函数</li>
<li>sizeof返回一个对象或类型所占的内存字节数，不会对其中的数据或指针做运算</li>
<li>strlen返回一个字符串的长度，不包括&rsquo;/0'</li>
</ul>
<h3 id="sizeofstruct和内存对齐" class="headerLink">
    <a href="#sizeofstruct%e5%92%8c%e5%86%85%e5%ad%98%e5%af%b9%e9%bd%90" class="header-mark"></a>sizeof(struct)和内存对齐</h3><p>内存对齐作用：</p>
<ul>
<li>移植原因：某些硬件平台只能在某些特定地址处取特定类型的数据；</li>
<li>性能原因：数据结构(尤其是栈)应尽可能在自然边界上对齐，未对齐内存需要做两次内存访问，对齐内存仅需要一次</li>
</ul>
<p>struct内存对齐原则：</p>
<ul>
<li>结构体成员中，第一个成员偏移量是0，排列在后面的成员的当前偏移量必须是当前成员类型的整数倍</li>
<li>结构体本身占用内存大小，应是结构体内最大数据成员的最小整数倍</li>
<li>**pragma pack(n)**预编译指令，所有成员对齐以n字节为准，不再考虑当前类型和最大结构体内类型</li>
</ul>
<p>union内存对齐原则：</p>
<ul>
<li>union字节数必须是占用字节数最多的成员的字节数的倍数，而且需要能够容纳其他成员</li>
</ul>
<h3 id="char--constconst-char-" class="headerLink">
    <a href="#char--constconst-char-" class="header-mark"></a>char * const，const char *</h3><ul>
<li>const char <em>ptr指向字符常量的指针，ptr是一个char</em>类型的常量，所指向的内容不能修改；</li>
<li>char * const ptr指向字符的指针常数，即const指针，不能修改ptr指针，但可以修改该指针指向的内容</li>
</ul>]]></description>
</item><item>
    <title>面向对象程序设计</title>
    <link>https://blog.ralvines.top/oop/</link>
    <pubDate>Wed, 01 Mar 2023 20:20:40 &#43;0800</pubDate><author>
                        <name>Ralvine</name><uri>https://blog.ralvines.top/about/praise/</uri><email>ralvine@163.com</email></author><guid>https://blog.ralvines.top/oop/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://z1.ax1x.com/2023/10/23/piAWIwd.png" referrerpolicy="no-referrer">
            </div><div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>课程信息<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">🎓 计算机科学与技术学院<br>
🕙 2022-2023 春夏<br>
🧑‍🏫 许威威<br>
📝 50%作业，50%期末</div>
        </div>
    </div>

    
<h2 id="介绍1" class="headerLink">
    <a href="#%e4%bb%8b%e7%bb%8d1" class="header-mark"></a>介绍<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></h2><p>Buzzwords</p>
<ul>
<li>继承</li>
<li>cohesion 凝聚</li>
<li>coupling 耦合</li>
<li>overriding</li>
<li>interface 接口</li>
<li>polymorphic 多态
<ul>
<li>polymorphic method calls</li>
</ul>
</li>
<li>matator methods</li>
<li>Encapsulation 封装</li>
</ul>
<p>C的优缺点&amp;C++新特性</p>
<h2 id="引用" class="headerLink">
    <a href="#%e5%bc%95%e7%94%a8" class="header-mark"></a>引用</h2><p>函数swap操作形参无法交换外部变量，C用指针，C++引入引用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span><span class="o">&amp;</span> <span class="n">SetValue</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">SetValue</span><span class="p">()</span><span class="o">=</span><span class="mi">40</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// Output: 40.
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="常量" class="headerLink">
    <a href="#%e5%b8%b8%e9%87%8f" class="header-mark"></a>常量</h2><p>区别define，有类型检查。</p>
<p>常量指针，不允许通过指针修改目标内容，但可以改变指向对象。</p>
<p>在函数形参中使用，防止形参被修改</p>
<p>常量成员函数：不应修改其所作用的对象（除了静态成员变量）</p>
<p>常量对象 <code>const Sample o;</code> 不可修改对象，但是可以执行其中的常量成员函数。</p>
<p>成员函数名字参数相同，有无const的区别属于重载关系。（实例对象是否常量决定了调用哪个成员函数）</p>
<p>常引用：对象作函数参数，为了避免复制构造函数降低效率，直接用引用，而为了防止实参跟着变，采用常引用。</p>
<h2 id="动态内存分配" class="headerLink">
    <a href="#%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d" class="header-mark"></a>动态内存分配</h2><p>分配变量：<code>int* P; P=new T;</code></p>
<p>T是任意类型名，相当于开辟了sizeof(T)的空间，P是指向它起始地址的指针，即T*.</p>
<p>释放：只能delete一次，对数组应为<code>delete [] p;</code></p>
<p>不delete就不会释放！</p>
<h2 id="内联函数重载和缺省参数" class="headerLink">
    <a href="#%e5%86%85%e8%81%94%e5%87%bd%e6%95%b0%e9%87%8d%e8%bd%bd%e5%92%8c%e7%bc%ba%e7%9c%81%e5%8f%82%e6%95%b0" class="header-mark"></a>内联函数、重载和缺省参数</h2><p>函数调用存在开销，调用本身耗时，内联函数在编译时直接插入函数内操作本身，但程序体积会变大。</p>
<p><code>inline int func(parameter) {}</code></p>
<p>函数名字相同但参数个数或类型不同，叫做重载。使函数命名简单，编译器自动判断调用哪个函数。二义性，调用函数的参数匹配不上。</p>
<p>缺省参数，最右边连续若干个参数可有缺省值。</p>
<p><code>void func(int x1, int x2=2, int x3=3) {}</code></p>
<h2 id="类和对象" class="headerLink">
    <a href="#%e7%b1%bb%e5%92%8c%e5%af%b9%e8%b1%a1" class="header-mark"></a>类和对象</h2><p>C语言：结构化程序设计，程序=数据结构+算法，但函数和操作的数据结构没有直接联系，规模增大后难以理解、扩充、查错。</p>
<p>C++：面向对象程序</p>
<p>指针方式：<code>ClassName* p= &amp;AClassObject</code>，用 - &gt; 指向其成员变量或函数。</p>
<p>引用方式：<code>ClassName&amp; p= AClassObject</code> 同时跟着变。</p>
<p>私有成员：缺省=private，同Class其他对象的私有成员也可访问。</p>
<p>成员函数也可重载、参数缺省。</p>
<h2 id="构造函数" class="headerLink">
    <a href="#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0" class="header-mark"></a>构造函数</h2><p>一个类可以有多个构造函数。</p>
<p>对象数组，注意动态分配时没定义就不初始化。</p>
<p>复制构造函数，参数必须引用<code>X::X(X&amp; x)</code>；起作用：直接<code>Complex c2(c1)</code>，或者函数参数或返回值含有该类对象；但是对象间赋值不会调用复制构造函数。</p>
<p>常量引用参数：减少开销，确保实参值不变时使用。</p>
<p>类型转换构造函数：只含一个参数。</p>
<p>析构函数：有对象数组情况下，程序结束时每个元素都会调用析构函数；临时对象和形参对象消亡都会调用。</p>
<p>局部对象：<code>{ 生命周期 }</code>，静态对象static：函数结束时不消亡。</p>
<p>不同编译器输出有所差别，有的做了优化，赋值可以不用再临时生成被复制的对象。</p>
<h2 id="this指针" class="headerLink">
    <a href="#this%e6%8c%87%e9%92%88" class="header-mark"></a>this指针</h2><p>C++编译先翻译成C时，Class变为Struct，因此需要多一个this指针指向函数作用的对象。因此可以返回对象自身。</p>
<p>静态成员函数则不可使用this指针，因为其不具体作用于某个对象。</p>
<h2 id="静态成员变量" class="headerLink">
    <a href="#%e9%9d%99%e6%80%81%e6%88%90%e5%91%98%e5%8f%98%e9%87%8f" class="header-mark"></a>静态成员变量</h2><p>静态成员为所有对象共享，总共就一份。sizeof()计算对象时不会计算其static成员变量。</p>
<p>访问方式。需要在定义类的文件中单独进行声明或初始化！</p>
<p>静态成员<strong>函数</strong>还可以直接通过整个类进行调用。</p>
<p>本质是全局变量，只是放在类中。例：方体类的实例总数。</p>
<p>⬆️缺陷，若实例对象是复制构造生成的，Total会有遗漏，特别是临时对象消亡时还会调用析构函数，因此需要单独写一个复制构造函数。</p>
<p>静态成员<strong>函数</strong>不能调用非静态的成员变量或函数。</p>
<h2 id="成员对象和封闭类" class="headerLink">
    <a href="#%e6%88%90%e5%91%98%e5%af%b9%e8%b1%a1%e5%92%8c%e5%b0%81%e9%97%ad%e7%b1%bb" class="header-mark"></a>成员对象和封闭类</h2><p>Class中有成员变量为其他Class类型，即称其为成员对象。例如Class Car下有成员变量Engine，属于Engine类。</p>
<p>初始化列表：构造函数后直接赋值。</p>
<p>先执行封闭类下所有对象成员构造函数，再执行封闭类构造函数；析构时顺序相反。</p>
<h2 id="友元" class="headerLink">
    <a href="#%e5%8f%8b%e5%85%83" class="header-mark"></a>友元</h2><p>友元类，关系不能传递和继承。</p>
<h2 id="运算符重载" class="headerLink">
    <a href="#%e8%bf%90%e7%ae%97%e7%ac%a6%e9%87%8d%e8%bd%bd" class="header-mark"></a>运算符重载</h2><p>根据参数数目决定重载为成员函数或普通函数</p>
<p>赋值运算符的重载：以string为例，需要防止指向同一块内存。</p>
<p>此时返回对象需要引用，如<code>String&amp;</code>：应当保留运算符原本特性，使得允许a=b=c和(a=b)=c.</p>
<p>还需要防止s=s.</p>
<p>还需要为其写单独的复制构造函数。</p>
<p>若声明时直接赋值，属于调用构造函数。</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>智云课堂回放 <a href="https://classroom.zju.edu.cn/coursedetail?course_id=50910&amp;tenant_code=112" target="_blank" rel="noopener noreferrer">https://classroom.zju.edu.cn/coursedetail?course_id=50910&tenant_code=112</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>]]></description>
</item><item>
    <title>Matlab 曲线拟合工具箱 SRTP</title>
    <link>https://blog.ralvines.top/srtp/</link>
    <pubDate>Wed, 01 Mar 2023 13:20:40 &#43;0800</pubDate><author>
                        <name>Ralvine</name><uri>https://blog.ralvines.top/about/praise/</uri><email>ralvine@163.com</email></author><guid>https://blog.ralvines.top/srtp/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://z1.ax1x.com/2023/10/23/piADxe0.png" referrerpolicy="no-referrer">
            </div><h2 id="开发日志" class="headerLink">
    <a href="#%e5%bc%80%e5%8f%91%e6%97%a5%e5%bf%97" class="header-mark"></a>开发日志</h2><h3 id="2023526" class="headerLink">
    <a href="#2023526" class="header-mark"></a>2023.5.26</h3><ul>
<li>在函数说明文档中提供了<code>spapi</code>的部分具体实现方式</li>
</ul>
<h3 id="2023523" class="headerLink">
    <a href="#2023523" class="header-mark"></a>2023.5.23</h3><ul>
<li>对部分函数进行了单增排列和参数检查上的功能优化</li>
</ul>
<h3 id="2023518-会议记录" class="headerLink">
    <a href="#2023518-%e4%bc%9a%e8%ae%ae%e8%ae%b0%e5%bd%95" class="header-mark"></a>2023.5.18 会议记录</h3><ul>
<li>
<p><code>ba_obj</code> 中存放一个 <code>void *</code> 类型的指针，这种类型的指针可以被转化为任意类型的指针，用来指向其保存的数据的内存位置</p>
<ul>
<li>在构造 <code>ba_obj</code> 对象的时候传给其构造函数的指针尽量指向堆内存</li>
<li>若要指向栈内存，对象的生命周期需要开发者自行维护。</li>
<li>注：若使用栈内存构造一个 <code>ba_obj</code> 对象，在离开当前作用域之后该 <code>ba_obj</code> 对象仍被使用，则其内部指针指向的数据其实已经被释放，此时很可能会引发软件闪退问题</li>
</ul>
</li>
<li>
<p><code>ba_obj</code> 的设计初衷是用来保存和传递矩阵的，不要对 <code>ba_obj</code> 对象写下 <code>get&lt; int / double &gt;()</code></p>
</li>
<li>
<p><code>ba_obj</code> 的构造函数的参数中的指针参数也应该指向堆内存</p>
</li>
<li>
<p><code>ba_obj</code> 不需要指针参数的构造函数内部也是重新 <code>new</code> 了堆内存赋值给其保存的指针的</p>
</li>
<li>
<p>软件中的 <code>int,double</code> 被视为 $1 \times 1$ 的 <code>int,double</code> 矩阵，不存在C++中独立的 <code>int,double</code></p>
</li>
<li>
<p><code>baltam::structure</code> 中保存一个 <code>std::map&lt;std::string, ba_obj_ptr&gt;</code> 作为存储数据的数据结构</p>
<ul>
<li>其 <code>map</code> 的 <code>value</code> 是指向 <code>ba_obj</code> 的智能指针</li>
<li>在给 <code>baltam::structure</code> 使用 <code>set_field(key,value_ptr)</code> 函数添加字段 <code>key</code> 的时候，数据指针<code>value_ptr</code> 应指向堆内存</li>
</ul>
</li>
<li>
<p>测试脚本的两个目的</p>
<ul>
<li>给不熟悉相关理论的用户一个快速上手的示例</li>
<li>测试函数的功能</li>
</ul>
</li>
<li>
<p>对于错误输入的处理并不一定要与MATLAB相同，可以更多的考虑相关理论的背景，报错与否一个重要的考量是用户友好</p>
</li>
</ul>
<h3 id="2023516" class="headerLink">
    <a href="#2023516" class="header-mark"></a>2023.5.16</h3><ul>
<li>改写并优化了<code>fnval</code>和<code>fnder</code>的测试脚本</li>
</ul>
<h3 id="2023513" class="headerLink">
    <a href="#2023513" class="header-mark"></a>2023.5.13</h3><ul>
<li>新增<code>spapi</code>函数说明</li>
</ul>
<h3 id="202359" class="headerLink">
    <a href="#202359" class="header-mark"></a>2023.5.9</h3><ul>
<li>新增测试 <code>test_fnval.m</code> 和 <code>test_fnder.m</code></li>
</ul>
<h3 id="2023424" class="headerLink">
    <a href="#2023424" class="header-mark"></a>2023.4.24</h3><ul>
<li>优化了函数说明文档，统一了表达方式和字体样式</li>
<li>更正了<code>fnder</code>和<code>ppmak</code>文档中的错误表述</li>
</ul>
<h3 id="2023412-会议记录" class="headerLink">
    <a href="#2023412-%e4%bc%9a%e8%ae%ae%e8%ae%b0%e5%bd%95" class="header-mark"></a>2023.4.12 会议记录</h3><ul>
<li>介绍开发环境与插件的机制及开发规范，具体可见
<a href="http://183.66.214.98:20005/numerical_computation/style_guide/-/wikis/C&#43;&#43;-%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83" target="_blank" rel="noopener noreferrer">C++ 开发规范</a>
<a href="https://www.bilibili.com/video/BV1SW4y1j71Y/?spm_id_from=333.999.0.0&amp;vd_source=ee756967a7f488a76fc48a6117203f55" target="_blank" rel="noopener noreferrer">mac操作系统使用安装北太天元</a></li>
<li>内核的使用文档，具体可见 <code>spline/deps/core/share/doc/html</code></li>
<li>报bug的方式：在gitlab中的议题中报</li>
<li>介绍源码的调试方法，文档可见
<a href="http://183.66.214.98:20005/numerical_computation/style_guide/-/wikis/CLion%E8%B0%83%E8%AF%95baltam%E4%BE%9D%E8%B5%96%E7%9A%84%E5%8A%A8%E6%80%81%E5%BA%93" target="_blank" rel="noopener noreferrer">CLion调试baltam依赖的动态库</a></li>
<li>讲解test测试脚本的书写和保留及函数说明文档的书写</li>
</ul>
<h3 id="202349" class="headerLink">
    <a href="#202349" class="header-mark"></a>2023.4.9</h3><ul>
<li>在<code>.gitignore</code>新增了对部分开发环境下冗余文件的忽略</li>
</ul>
<h3 id="202347" class="headerLink">
    <a href="#202347" class="header-mark"></a>2023.4.7</h3><ul>
<li>新增 <code>fn2fm</code> 函数功能 <code>ns = fn2fm(s,form)</code>的使用文档</li>
<li>新增 <code>fnder</code> 函数功能 <code>ds = fnder(s,order)</code>的使用文档</li>
</ul>]]></description>
</item><item>
    <title>数据结构与算法</title>
    <link>https://blog.ralvines.top/dsa/</link>
    <pubDate>Wed, 01 Sep 2021 20:20:40 &#43;0800</pubDate><author>
                        <name>Ralvine</name><uri>https://blog.ralvines.top/about/praise/</uri><email>ralvine@163.com</email></author><guid>https://blog.ralvines.top/dsa/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://z1.ax1x.com/2023/10/23/piAW5eH.png" referrerpolicy="no-referrer">
            </div><div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>课程信息<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">🎓 数学科学学院<br>
🕙 2021-2022 秋冬<br>
🧑‍🏫 王何宇<br>
📝 作业，项目作业，期末考试</div>
        </div>
    </div>

    


    <div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw"></i>课程材料<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><ul>
<li>《Mathematical Foundations for Data Analysis》Jeff M. Phillips</li>
</ul>
</div>
        </div>
    </div>

    


    <div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw"></i>课程大纲<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><ul>
<li>CH3. 链表、栈和队列</li>
<li>CH4. 树</li>
<li>CH5. 哈希</li>
<li>CH6. 优先队列和堆</li>
<li>CH7. 分类</li>
<li>CH8. *</li>
<li>CH9. 图</li>
<li>Extra. 主定理</li>
</ul>
</div>
        </div>
    </div>

    
<h2 id="c-基础知识" class="headerLink">
    <a href="#c-%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86" class="header-mark"></a>C++ 基础知识</h2><h3 id="动态内存与释放" class="headerLink">
    <a href="#%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98%e4%b8%8e%e9%87%8a%e6%94%be" class="header-mark"></a>动态内存与释放</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">;</span> <span class="k">delete</span> <span class="p">[]</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Birds</span><span class="p">()</span> <span class="p">{</span><span class="n">name</span><span class="o">=</span><span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">256</span><span class="p">]}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>利用指针实现动态内存分配。同值对象指向相同address</p>
<p>Shell命令查看内存泄漏状况<code>valgrind filename</code></p>
<p>释放内存：及时delete变量。由于为指针，要防止指向新地址时原内存未被释放。</p>
<h3 id="template" class="headerLink">
    <a href="#template" class="header-mark"></a>template</h3><p>编译时自动填充typename
在类外撰写类成员函数时需要添加
可指定T的具体类型</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">FunctionName</span><span class="p">(</span><span class="k">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">_obj</span><span class="p">)</span> <span class="p">{}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="关键字修饰符" class="headerLink">
    <a href="#%e5%85%b3%e9%94%ae%e5%ad%97%e4%bf%ae%e9%a5%b0%e7%ac%a6" class="header-mark"></a>关键字修饰符</h3><h4 id="const" class="headerLink">
    <a href="#const" class="header-mark"></a>const</h4><p>对成员函数：修饰非静态数据，只读化。应尽可能将该成员函数声明为const 成员函数，除非成员函数需要修改数据成员。const可访问非常量数据，反之不可。指针数据可以被const 函数修改。
<code>Class:: func() const {}</code></p>
<p>对形参：指针传递，禁止修改指针指向地址内存数据；值传递不需要const保护。</p>
<p><code>void copyMemory(const T* _s,T* _d,int _n);</code></p>
<h4 id="static" class="headerLink">
    <a href="#static" class="header-mark"></a>static</h4><p>静态变量，延长生命周期又相较全局变量保留了一定的访问范围。需要一个数据对象为整个类而非某个对象服务,同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部时使用。</p>
<h4 id="this" class="headerLink">
    <a href="#this" class="header-mark"></a>*this</h4><p>指向obj自身的指针</p>
<h4 id="explicit-显式转换" class="headerLink">
    <a href="#explicit-%e6%98%be%e5%bc%8f%e8%bd%ac%e6%8d%a2" class="header-mark"></a>explicit 显式转换</h4><p><code>explicit</code> 对单参数构造函数限制隐式转换
防止编译器进行类型等方式的强制转换。</p>
<h3 id="宏定义" class="headerLink">
    <a href="#%e5%ae%8f%e5%ae%9a%e4%b9%89" class="header-mark"></a>宏定义</h3><p>用于简化重复语句<code>#define TEMP template&lt;typename T&gt;</code></p>
<p>编译处理</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#ifndef xxx
</span></span></span><span class="line"><span class="cl"><span class="cp">#define xxx
</span></span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="传递-引用" class="headerLink">
    <a href="#%e4%bc%a0%e9%80%92-%e5%bc%95%e7%94%a8" class="header-mark"></a>传递 引用</h3><h4 id="形参的值传递-指针传递-引用传递" class="headerLink">
    <a href="#%e5%bd%a2%e5%8f%82%e7%9a%84%e5%80%bc%e4%bc%a0%e9%80%92-%e6%8c%87%e9%92%88%e4%bc%a0%e9%80%92-%e5%bc%95%e7%94%a8%e4%bc%a0%e9%80%92" class="header-mark"></a>形参的值传递 指针传递 引用传递</h4><p>默认为值传递，开辟新函数，储存实参数据；指针实质存在一层中介地址，引用传递直接对传入对象进行修改；</p>
<p><code>*&amp;obj</code> 适用于struct对象，对其属性变量进行修改</p>
<ol>
<li><code>T* a</code> ： 传递实参指针地址，及最终指向数据地址，但可以利用*a修改地址内存数据</li>
<li><code>T&amp; a</code> ：左值引用，实参的别名</li>
</ol>
<h4 id="左值-右值引用" class="headerLink">
    <a href="#%e5%b7%a6%e5%80%bc-%e5%8f%b3%e5%80%bc%e5%bc%95%e7%94%a8" class="header-mark"></a>左值 右值引用</h4><p>右值引用 <code>&amp;&amp;</code> ：防止传递给形参 <code>T&amp; a</code> 的是常量（此时函数无法修改a）</p>
<p><strong>看能不能对表达式取地址，如果能，则为左值，否则为右值</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">&amp;</span><span class="n">d</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// error.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">d</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>约定</strong> rhs：引用；lhs：赋值</p>
<h3 id="stdmove" class="headerLink">
    <a href="#stdmove" class="header-mark"></a>std::move</h3><p>强制将左值转换为右值引用，如 <code>push_back</code> 避免开辟新内存</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">AvlNode</span><span class="p">(</span><span class="k">const</span> <span class="n">Comparable</span> <span class="o">&amp;</span> <span class="n">ele</span><span class="p">,</span> <span class="n">AvlNode</span> <span class="o">*</span><span class="n">lt</span><span class="p">,</span> <span class="n">AvlNode</span> <span class="o">*</span><span class="n">rt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span> <span class="n">element</span><span class="p">{</span><span class="n">ele</span><span class="p">},</span> <span class="n">left</span><span class="p">{</span><span class="n">lt</span><span class="p">},</span> <span class="n">right</span><span class="p">{</span><span class="n">rt</span><span class="p">},</span> <span class="n">height</span><span class="p">{</span><span class="n">h</span><span class="p">}</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="n">AvlNode</span><span class="p">(</span><span class="n">Comparable</span> <span class="o">&amp;&amp;</span> <span class="n">ele</span><span class="p">,</span> <span class="n">AvlNode</span> <span class="o">*</span><span class="n">lt</span><span class="p">,</span> <span class="n">AvlNode</span> <span class="o">*</span><span class="n">rt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span> <span class="n">element</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ele</span><span class="p">)},</span> <span class="n">left</span><span class="p">{</span><span class="n">lt</span><span class="p">},</span> <span class="n">right</span><span class="p">{</span><span class="n">rt</span><span class="p">},</span> <span class="n">height</span><span class="p">{</span><span class="n">h</span><span class="p">}</span> <span class="p">{}</span> <span class="c1">//参数无地址，临时ele=参数
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="class--struct-封装" class="headerLink">
    <a href="#class--struct-%e5%b0%81%e8%a3%85" class="header-mark"></a>Class &amp; Struct 封装</h3><p>外部只提供相应功能的接口，不允许直接对底层对象进行修改。</p>
<h4 id="复制构造函数" class="headerLink">
    <a href="#%e5%a4%8d%e5%88%b6%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0" class="header-mark"></a>复制构造函数</h4><p>将b中成员属性复制到c： <code>Birds c(b);</code>
类中处理：定义拷贝函数；否则：缺省。
需要开辟新的动态内存</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Birds</span><span class="p">(</span><span class="n">Birds</span> <span class="n">_obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">name</span><span class="o">=</span><span class="k">new</span> <span class="kt">char</span> <span class="p">[</span><span class="mi">256</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl"><span class="n">for循环迭代载入name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">_obj</span><span class="p">.</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="函数化" class="headerLink">
    <a href="#%e5%87%bd%e6%95%b0%e5%8c%96" class="header-mark"></a>函数化</h4><p>如复制构造函数中的copyMemory，便于多核并行运算。</p>
<h4 id="struct-定义传入参数" class="headerLink">
    <a href="#struct-%e5%ae%9a%e4%b9%89%e4%bc%a0%e5%85%a5%e5%8f%82%e6%95%b0" class="header-mark"></a>struct 定义传入参数</h4><p>使得struct能够直接在定义时传入相应参数</p>
<p><code>BinaryNode(const Comparable&amp; theElement, BinaryNode *lt, BinaryNode *rt): element(theElement),left(lt),right(rt) {}</code></p>
<h4 id="operator-重载运算符" class="headerLink">
    <a href="#operator-%e9%87%8d%e8%bd%bd%e8%bf%90%e7%ae%97%e7%ac%a6" class="header-mark"></a>Operator 重载运算符</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">const Array&amp; operator=(const Array&amp; _obj)
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="注释" class="headerLink">
    <a href="#%e6%b3%a8%e9%87%8a" class="header-mark"></a>注释</h3><p>doxymacs/doxygen格式的注释：
可以通过命令提取所有相应注释以html方式直观显示。</p>
<h3 id="standard-template-library" class="headerLink">
    <a href="#standard-template-library" class="header-mark"></a>Standard Template Library</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// get random number.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">srand</span><span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">time</span><span class="p">(</span><span class="k">nullptr</span><span class="p">));</span> <span class="c1">// 随机种子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">a</span><span class="o">=</span><span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="mi">10</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">abs</span><span class="p">();</span><span class="n">min</span><span class="p">();</span><span class="n">max</span><span class="p">();</span><span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">sqrt</span><span class="p">();</span><span class="n">sin</span><span class="p">();</span><span class="n">cos</span><span class="p">();</span><span class="n">tan</span><span class="p">();</span><span class="n">pow</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">clock_t</span> <span class="n">start</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="复杂度" class="headerLink">
    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6" class="header-mark"></a>复杂度</h2><h3 id="big-o" class="headerLink">
    <a href="#big-o" class="header-mark"></a>big O</h3><p>$1000N=O(N^2); (logN)^k=O(N);$</p>
<p>$1 &lt; logN &lt; N &lt; NlogN &lt; N^2$</p>
<h3 id="时间复杂度" class="headerLink">
    <a href="#%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6" class="header-mark"></a>时间复杂度</h3><ul>
<li>for循环｜内语句*迭代次数；嵌套循环</li>
<li>顺序语句｜求和，取Max；判定语句</li>
<li>NlogN|最大子序列问题 一次N遍历&amp;一次二分查找</li>
<li>logN｜二分搜索，欧几里得</li>
</ul>
<h2 id="主定理" class="headerLink">
    <a href="#%e4%b8%bb%e5%ae%9a%e7%90%86" class="header-mark"></a>主定理</h2><p><strong>归纳法证明：</strong></p>
<p>（例）</p>
<p><strong>一般性证明：</strong></p>
<p>构造树，$\text{depth}=log(b,n)，\text{widget}=a^{(log(b,n))}=n^{(log(b,a))}$</p>


    <div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw"></i>实例：二分查找<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>$T(n) = T(n/2) + O(1)$</p>
<p>$T(n/2) = T(n/4) + O(1)$</p>
<p>$&hellip;$</p>
<p>$T(2) = T(1) + O(1)$</p>
<p>$T(1) = O(1)$</p>
<p>$a=1,b=2,k=0$ 代入得 $O(logN)$;</p>
</div>
        </div>
    </div>

    
<p>另可直接证，由于为$1/2,1/4&hellip;1/n$, 尾项$2^k$项为$n$，故共$logn$项，$$T(n)=logn\times o(1)=logn$$</p>
<h2 id="vector--list--stack--queues" class="headerLink">
    <a href="#vector--list--stack--queues" class="header-mark"></a>Vector &amp; List &amp; Stack &amp; Queues</h2><h3 id="iterator" class="headerLink">
    <a href="#iterator" class="header-mark"></a>iterator</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">iterator</span> <span class="n">a</span><span class="o">=</span><span class="n">A</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">i</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="vector--list" class="headerLink">
    <a href="#vector--list" class="header-mark"></a>Vector &amp; List</h3><ul>
<li>Array | 经典数组</li>
<li>Vector | 批量分配内存的数组，空间不够时再申请新的内存；模板化<code>&lt;T&gt;</code>；允许拷贝赋值</li>
<li>List | 链表 Single/Double-Linked-List <strong>双链表</strong> 表头、尾、哨兵结点</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//10个初值为1的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">b</span><span class="p">.</span><span class="n">begin</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//共有
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">a</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="n">a</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="p">.</span><span class="n">front</span><span class="p">();</span><span class="n">a</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span><span class="c1">//现有元素数目调整,多删少补,未给定参数2则随机
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Vector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="n">a</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span><span class="n">a</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span><span class="c1">//容量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// List
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">a</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="n">a</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">single_val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="n">a</span><span class="p">.</span><span class="n">remove_if</span><span class="p">(</span><span class="n">condition</span><span class="p">);</span><span class="n">a</span><span class="p">.</span><span class="n">unique</span><span class="p">();</span><span class="c1">//去重
</span></span></span></code></pre></td></tr></table>
</div>
</div><table>
<thead>
<tr>
<th>类型</th>
<th>Access</th>
<th>Insert</th>
<th>Delete</th>
<th>Search</th>
</tr>
</thead>
<tbody>
<tr>
<td>Array/Vector</td>
<td>1</td>
<td>n</td>
<td>n</td>
<td>n</td>
</tr>
<tr>
<td>Single-linked-List</td>
<td>n</td>
<td>1</td>
<td>1</td>
<td>n</td>
</tr>
<tr>
<td>Double-linked-List</td>
<td>n</td>
<td>1</td>
<td>1</td>
<td>n</td>
</tr>
</tbody>
</table>
<h3 id="stack--queue" class="headerLink">
    <a href="#stack--queue" class="header-mark"></a>Stack &amp; Queue</h3><p><code>pop() push() size() swap() empty();</code></p>
<ul>
<li>Stack: LIFO <code>top();</code></li>
<li>Queue: FIFO <code>front() back();</code></li>
</ul>
<h4 id="stack-计算器" class="headerLink">
    <a href="#stack-%e8%ae%a1%e7%ae%97%e5%99%a8" class="header-mark"></a>Stack 计算器</h4><ul>
<li>前缀/后缀。</li>
<li><strong>中缀转后缀：</strong><code>A+B*(C-D)-E/F</code>转为<code>ABCD−∗+EF/−</code></li>
</ul>
<p>优先级设置 <code>‘*’ = ‘/’ &gt; ‘+’ = ‘-’ &gt;</code></p>
<ul>
<li>style1: <code>‘(’</code> 优先级最高，如直接读入；推入操作符时不弹</li>
<li>style2: <code>‘(’</code> 优先级最低，强制直接读入</li>
<li>数字直接放到[输出列]，右括号直接弹到左括号止；</li>
<li>操作符：栈弹出直到遇到比自己优先级低的操作符再入栈。</li>
<li>计算：顺序读取，数字入栈，符号弹出两数字运算，结果入栈。</li>
</ul>
<h2 id="树" class="headerLink">
    <a href="#%e6%a0%91" class="header-mark"></a>树</h2><p>Binary Tree 二叉树平均深度 $O(\sqrt{N})$ ，表达式树应用；</p>
<h3 id="二叉搜索树" class="headerLink">
    <a href="#%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91" class="header-mark"></a>二叉搜索树</h3><p>左小右大；平均深度 $O(logN)$ ，最坏深度 $O(N-1)$.</p>
<h4 id="构建" class="headerLink">
    <a href="#%e6%9e%84%e5%bb%ba" class="header-mark"></a>构建</h4><ul>
<li><code>contains</code>｜<code>findMin(Max)</code>｜<code>insert</code>｜<code>～</code></li>
<li><code>makeEmpty</code> 递归</li>
<li><code>copy</code> | clone，递归 <code>return new node</code>;</li>
<li>重载运算符：<code>this!=&amp;rhs</code> 则 <code>makeEmpty</code> 再 <code>clone rhs.root</code> ，最终 <code>return *this</code></li>
<li><code>remove</code> | <code>(*&amp;t)t</code> 为结点地址；空, <code>return</code>; <code>t&lt;&gt;x</code> 判断; <code>t=x</code>.</li>
<li>双子: <code>t-&gt;ele=findmax(t-&gt;right)-&gt;ele</code> , <code>remove(t-&gt;ele;t-&gt;right); // 右子找min代入t,删除该min</code></li>
<li>单子/无子: <code>T*oldNode=t</code> ,另引入的参数 <code>t=t-&gt;left/right</code> 相当于改结点地址为 t 左/右子，再删 <code>oldNode</code> 即删了原结点.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// findmin: 递归或while 注意空树直接返回nullptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BinaryNode</span> <span class="o">*</span> <span class="nf">findMin</span><span class="p">(</span> <span class="n">BinaryNode</span> <span class="o">*</span><span class="n">t</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">t</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">findMin</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// insert
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mf">1.</span><span class="k">if</span> <span class="n">t</span><span class="o">==</span><span class="k">nullptr</span><span class="o">:</span><span class="k">new</span> <span class="n">node</span><span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="k">nullptr</span><span class="p">,</span><span class="k">nullptr</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="mf">2.</span><span class="k">else</span> <span class="n">compare</span> <span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ele</span><span class="p">,</span><span class="err">递归</span>
</span></span><span class="line"><span class="cl"><span class="mf">3.</span><span class="n">balance</span> <span class="n">and</span> <span class="n">update</span> <span class="n">the</span> <span class="n">height</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">subtree</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">).</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="关于-struct-构造" class="headerLink">
    <a href="#%e5%85%b3%e4%ba%8e-struct-%e6%9e%84%e9%80%a0" class="header-mark"></a>关于 struct 构造</h4><ul>
<li><code>BinaryNode</code> 置于 private；针对 <code>struct</code> 的操作也位于 private 部分</li>
<li>外部操作 $\rightarrow$ public函数 $\rightarrow$ private函数</li>
</ul>
<h4 id="关于-function-参数" class="headerLink">
    <a href="#%e5%85%b3%e4%ba%8e-function-%e5%8f%82%e6%95%b0" class="header-mark"></a>关于 function 参数</h4><p>对 <code>Struct BinaryNode</code>，由于其 <code>element</code> 为变量，<code>left/right</code> 为指针，fuction 引用时应采用 <code>BinaryNode * &amp; t</code> ，引用 Node 地址。</p>
<h4 id="时间分析" class="headerLink">
    <a href="#%e6%97%b6%e9%97%b4%e5%88%86%e6%9e%90" class="header-mark"></a>时间分析</h4><ul>
<li>
<p>内部路径长｜所有结点的深度和</p>
</li>
<li>
<p>递推关系、秩，(average) $$D(N)=D(i)+D(N-i-1)+N-1 \Rightarrow O(NlogN)$$</p>
</li>
<li>
<p>任意结点预期深度 $logN$</p>
</li>
<li>
<p>交替 <code>insert/remove</code> $O(N^2)$ ，期望深度 $O(\sqrt{N})$</p>
</li>
</ul>
<h3 id="balance-树" class="headerLink">
    <a href="#balance-%e6%a0%91" class="header-mark"></a>Balance 树</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">/// Height 处理
</span></span></span><span class="line"><span class="cl"><span class="c1">// Binary Tree
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">height</span><span class="p">(</span> <span class="n">BinaryNode</span> <span class="o">*</span><span class="n">t</span> <span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">t</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">max</span><span class="p">(</span><span class="n">height</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">),</span> <span class="n">height</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// AVL Tree: Struct AvlNode has added the val &#39;height&#39;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">height</span><span class="p">(</span> <span class="n">AvlNode</span> <span class="o">*</span><span class="n">t</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">t</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="avl-树" class="headerLink">
    <a href="#avl-%e6%a0%91" class="header-mark"></a>AVL 树</h4><p>每个结点的左子树和右子树高度最多差1（空树为-1）</p>
<p><strong>Rotation的具体实现</strong></p>
<table>
<thead>
<tr>
<th>插入方式</th>
<th>描述</th>
<th>旋转方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>LL</td>
<td>在a的<strong>左子树</strong>根节点的<strong>左子树</strong>上插入节点而破坏平衡</td>
<td>右旋转</td>
</tr>
<tr>
<td>RR</td>
<td>在a的<strong>右子树</strong>根节点的<strong>右子树</strong>上插入节点而破坏平衡</td>
<td>左旋转</td>
</tr>
<tr>
<td>LR</td>
<td>在a的<strong>左子树</strong>根节点的<strong>右子树</strong>上插入节点而破坏平衡</td>
<td>先左旋后右旋</td>
</tr>
<tr>
<td>RL</td>
<td>在a的<strong>右子树</strong>根节点的<strong>左子树</strong>上插入节点而破坏平衡</td>
<td>先右旋后左旋</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// insert. 伪代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">x</span><span class="o">&lt;</span><span class="n">t</span><span class="o">-&gt;</span><span class="nl">ele</span><span class="p">:</span><span class="err">左插入，</span><span class="n">insert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">),</span><span class="err">此时判定</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="n">balance</span> <span class="nl">condition</span><span class="p">:</span><span class="n">height</span> <span class="n">of</span> <span class="n">left</span><span class="o">-</span><span class="n">right</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">then</span> <span class="k">if</span> <span class="n">x</span><span class="o">&lt;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">ele</span> <span class="err">即</span><span class="n">LL</span><span class="err">，对</span><span class="n">t调用右旋</span> <span class="c1">// 其余同理
</span></span></span><span class="line"><span class="cl"><span class="c1">// right rotation. (for LL-insert style)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">rotateWithLeftChild</span><span class="p">(</span> <span class="n">AvlNode</span> <span class="o">*</span> <span class="o">&amp;</span> <span class="n">k2</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">AvlNode</span> <span class="o">*</span><span class="n">k1</span> <span class="o">=</span> <span class="n">k2</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">k2</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">k1</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">k1</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">k2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// after rotation , update the height.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">k2</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span> <span class="n">height</span><span class="p">(</span> <span class="n">k2</span><span class="o">-&gt;</span><span class="n">left</span> <span class="p">),</span> <span class="n">height</span><span class="p">(</span> <span class="n">k2</span><span class="o">-&gt;</span><span class="n">right</span> <span class="p">)</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">k1</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span> <span class="n">height</span><span class="p">(</span> <span class="n">k1</span><span class="o">-&gt;</span><span class="n">left</span> <span class="p">),</span> <span class="n">k2</span><span class="o">-&gt;</span><span class="n">height</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">k2</span> <span class="o">=</span> <span class="n">k1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// LR-insert.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">doubleWithLeftChild</span><span class="p">(</span> <span class="n">AvlNode</span> <span class="o">*</span> <span class="o">&amp;</span> <span class="n">k3</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">rotateWithRightChild</span><span class="p">(</span> <span class="n">k3</span><span class="o">-&gt;</span><span class="n">left</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">rotateWithLeftChild</span><span class="p">(</span> <span class="n">k3</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>时间复杂度分析</strong></p>
<ul>
<li>计算高度O(logN)；</li>
<li>保证查询O(logN)避免Binary Tree最坏的N；</li>
<li>但由于旋转存在，操作效率低，特别是remove时可能需要一直旋转到根；</li>
<li>额外封装，繁琐。</li>
</ul>
<p><em>另一种写法：独立的balance操作</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// at the end of each insert or remove operation, you need to do &#34;balance(t)&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">ALLOWED_IMBALANCE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">balance</span><span class="p">(</span> <span class="n">AvlNode</span> <span class="o">*</span> <span class="o">&amp;</span> <span class="n">t</span> <span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">t</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">height</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span> <span class="p">)</span> <span class="o">-</span> <span class="n">height</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="n">ALLOWED_IMBALANCE</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">height</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">left</span> <span class="p">)</span> <span class="o">&gt;=</span> <span class="n">height</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">right</span> <span class="p">)</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">      <span class="n">rotateWithLeftChild</span><span class="p">(</span> <span class="n">t</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="k">else</span> 
</span></span><span class="line"><span class="cl">      <span class="n">doubleWithLeftChild</span><span class="p">(</span> <span class="n">t</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="n">height</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span> <span class="p">)</span> <span class="o">-</span> <span class="n">height</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="n">ALLOWED_IMBALANCE</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">height</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">right</span> <span class="p">)</span> <span class="o">&gt;=</span> <span class="n">height</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">left</span> <span class="p">)</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">      <span class="n">rotateWithRightChild</span><span class="p">(</span> <span class="n">t</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">      <span class="n">doubleWithRightChild</span><span class="p">(</span> <span class="n">t</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">t</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span> <span class="n">height</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span> <span class="p">),</span> <span class="n">height</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span> <span class="p">)</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="splay-树" class="headerLink">
    <a href="#splay-%e6%a0%91" class="header-mark"></a>Splay 树*</h4><p>保证从空树开始任意连续M次操作最多花费 $O(MlogN)$ 的时间</p>
<h3 id="traversals" class="headerLink">
    <a href="#traversals" class="header-mark"></a>Traversals</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 前序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">文件路径展开</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 中序 O(N)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span><span class="p">(</span> <span class="n">t</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">printTree</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">out</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">element</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">printTree</span><span class="p">(</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">out</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 后序 O(N)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">高度计算</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 层序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="o">&lt;</span><span class="n">queue</span><span class="o">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="b-树" class="headerLink">
    <a href="#b-%e6%a0%91" class="header-mark"></a>B 树*</h3><h3 id="sets--maps" class="headerLink">
    <a href="#sets--maps" class="header-mark"></a>Sets &amp; Maps</h3><ul>
<li>Sets｜排序、去重</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="c1">//logN
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">a</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="n">a</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="n">a</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Maps｜key-value(&gt;=1)</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// key:b-&gt;first; value:b-&gt;second....
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="哈希" class="headerLink">
    <a href="#%e5%93%88%e5%b8%8c" class="header-mark"></a>哈希</h2><ul>
<li>散列表</li>
<li><code>insert</code> / <code>search</code> / <code>delete</code></li>
<li>average:O(1)</li>
<li>Key -&gt; Table</li>
<li>素数</li>
<li>TableSize</li>
<li>collision</li>
</ul>
<h3 id="分析" class="headerLink">
    <a href="#%e5%88%86%e6%9e%90" class="header-mark"></a>分析</h3><p><strong>负数补偿？</strong></p>
<ul>
<li>value&lt;0，then+tableSize</li>
</ul>
<p><strong>均匀分配键：</strong></p>
<ul>
<li>单元数目有限，键数实际上无穷</li>
<li>习惯：0～tableSize-1</li>
<li>装填因子</li>
<li>分离链接法（缺点：内存分配耗时）</li>
<li>除了链表，也可用二叉树/新散列表</li>
</ul>
<h3 id="开放寻址法" class="headerLink">
    <a href="#%e5%bc%80%e6%94%be%e5%af%bb%e5%9d%80%e6%b3%95" class="header-mark"></a>开放寻址法</h3><ul>
<li>
<p>冲突解决函数，$\lambda&lt;0.5$ 聚集效应, $f(i)$ 为冲突点与探查点的距离</p>
</li>
<li>
<p>线性探测: $f(i)=i$ ；一次聚集-占据单元形成区块</p>
</li>
<li>
<p>平方探测: $f(i)=i^2$ 二次聚集</p>
<p><em>保证表的大小是素数，否则表被填满一半就找不到空单元了</em></p>
</li>
<li>
<p>双散列:f(i)=i*hash(x),结果不可以为0；example，hash(x)=R-(xmodR)</p>
</li>
</ul>
<h3 id="再散列" class="headerLink">
    <a href="#%e5%86%8d%e6%95%a3%e5%88%97" class="header-mark"></a>再散列</h3><ul>
<li>$O(N)$</li>
<li>一半/插满的策略</li>
<li>途中策略：某一装填因子</li>
</ul>
<h3 id="可扩散列" class="headerLink">
    <a href="#%e5%8f%af%e6%89%a9%e6%95%a3%e5%88%97" class="header-mark"></a>可扩散列*</h3><h2 id="priority-queues--heaps" class="headerLink">
    <a href="#priority-queues--heaps" class="header-mark"></a>Priority Queues &amp; Heaps</h2><h3 id="二叉堆" class="headerLink">
    <a href="#%e4%ba%8c%e5%8f%89%e5%a0%86" class="header-mark"></a>二叉堆</h3><ul>
<li>完全二叉树</li>
<li>最小堆、最大堆</li>
<li>数组存储 $i,2i,2i+1$</li>
<li>查找 $O(N)$</li>
<li>堆序性质</li>
</ul>
<p><strong>为何选用Heap？</strong></p>
<ul>
<li>Min/Max: $O(1)$</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span> <span class="k">const</span> <span class="n">Comparable</span> <span class="o">&amp;</span> <span class="n">x</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// check size.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span> <span class="n">currentSize</span> <span class="o">==</span> <span class="n">array</span><span class="p">.</span><span class="n">size</span><span class="p">(</span> <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="n">array</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span> <span class="n">array</span><span class="p">.</span><span class="n">size</span><span class="p">(</span> <span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Percolate up 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">hole</span> <span class="o">=</span> <span class="o">++</span><span class="n">currentSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Comparable</span> <span class="n">copy</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">array</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">copy</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">array</span><span class="p">[</span> <span class="n">hole</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">];</span> <span class="n">hole</span> <span class="o">/=</span> <span class="mi">2</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">array</span><span class="p">[</span> <span class="n">hole</span> <span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">array</span><span class="p">[</span> <span class="n">hole</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">]</span> <span class="p">);</span> <span class="c1">// 规避大量交换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">array</span><span class="p">[</span> <span class="n">hole</span> <span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">array</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="applications-of-priority-queues" class="headerLink">
    <a href="#applications-of-priority-queues" class="header-mark"></a>Applications of Priority Queues</h3><h2 id="排序" class="headerLink">
    <a href="#%e6%8e%92%e5%ba%8f" class="header-mark"></a>排序</h2><h3 id="插入排序" class="headerLink">
    <a href="#%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f" class="header-mark"></a>插入排序</h3><h3 id="快排" class="headerLink">
    <a href="#%e5%bf%ab%e6%8e%92" class="header-mark"></a>快排</h3><h4 id="pivot策略" class="headerLink">
    <a href="#pivot%e7%ad%96%e7%95%a5" class="header-mark"></a>Pivot策略</h4><p><strong>最好/坏可能性</strong></p>
<ul>
<li>随机选择待排序序列中的一个数字作为划分字问题的标准，划分是否平均影响算法复杂度</li>
<li>每次问题规模减半，$a=2，b=2，d=1$</li>
<li>复杂度为 $n^2 log(n)$</li>
<li>最差情况下，复杂度为 $O(n^2)$</li>
</ul>
<h4 id="选择的线性期望时间算法" class="headerLink">
    <a href="#%e9%80%89%e6%8b%a9%e7%9a%84%e7%ba%bf%e6%80%a7%e6%9c%9f%e6%9c%9b%e6%97%b6%e9%97%b4%e7%ae%97%e6%b3%95" class="header-mark"></a>选择的线性期望时间算法</h4><h3 id="线性时间排序-bucket-sort-and-radix-sort-复杂度分析" class="headerLink">
    <a href="#%e7%ba%bf%e6%80%a7%e6%97%b6%e9%97%b4%e6%8e%92%e5%ba%8f-bucket-sort-and-radix-sort-%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90" class="header-mark"></a>线性时间排序: Bucket Sort and Radix Sort 复杂度分析</h3><h3 id="计基数排序非比较算法" class="headerLink">
    <a href="#%e8%ae%a1%e5%9f%ba%e6%95%b0%e6%8e%92%e5%ba%8f%e9%9d%9e%e6%af%94%e8%be%83%e7%ae%97%e6%b3%95" class="header-mark"></a>计（基）数排序——非比较算法</h3><ul>
<li>对于待排序的整数序列，从最低位到最高位每次按照相应的位排序一次</li>
<li>每次递归问题规模变为原来的1/10，但需要求解10个子问题，额外运算为 $O(n)$ 的，$a=10，b=10，d=1$</li>
<li>复杂度为 $n^1 log(n) = nlog(n)$ ，近似为 $O(kN)$ ，k为整数的位数</li>
</ul>
<h3 id="归并排序堆排序" class="headerLink">
    <a href="#%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f%e5%a0%86%e6%8e%92%e5%ba%8f" class="header-mark"></a>归并排序/堆排序</h3><p>归并排序</p>
<ul>
<li>数据列均分为两部分，分别排序，之后以 $O(n)$ 的复杂度进行合并，空间复杂度 $O(n)$</li>
<li>每次问题规模减半，$a=2，b=2，d=1$</li>
<li>复杂度为 $nlog(n)$</li>
</ul>
<h2 id="图论" class="headerLink">
    <a href="#%e5%9b%be%e8%ae%ba" class="header-mark"></a>图论</h2><ul>
<li>G[graph] -&gt; V[vertex]</li>
<li>E[edge(arc)], path</li>
<li>digraph 有向</li>
<li>Weight&amp;cost 权/值</li>
<li>Adjacent 邻接</li>
<li>cycle 回路：满足 $w1=wN$ , length&gt;=1</li>
<li>loop 环：回到自身，length=0</li>
<li>Simple path 简单路径</li>
<li>强/弱连通、基础图/完全图</li>
</ul>
<h3 id="表示" class="headerLink">
    <a href="#%e8%a1%a8%e7%a4%ba" class="header-mark"></a>表示</h3><ul>
<li>Adjacent Matrix：dense <code>A[u][v]</code></li>
<li>Adjacent List：sparse $O(|E|+|V|) $</li>
</ul>
<h3 id="拓扑排序" class="headerLink">
    <a href="#%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f" class="header-mark"></a>拓扑排序</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-&gt; delete v1, neighbors indegree-1 
</span></span><span class="line"><span class="cl">-&gt; find indegree=0 v2
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>$O(V^2)$ using <code>&lt;Queue&gt;</code></li>
</ul>
<h3 id="dijkstras" class="headerLink">
    <a href="#dijkstras" class="header-mark"></a>Dijkstras</h3><h3 id="最坏可能" class="headerLink">
    <a href="#%e6%9c%80%e5%9d%8f%e5%8f%af%e8%83%bd" class="header-mark"></a>最坏可能</h3><h3 id="可对负边权使用的算法" class="headerLink">
    <a href="#%e5%8f%af%e5%af%b9%e8%b4%9f%e8%be%b9%e6%9d%83%e4%bd%bf%e7%94%a8%e7%9a%84%e7%ae%97%e6%b3%95" class="header-mark"></a>可对负边权使用的算法</h3><h3 id="最小生成树" class="headerLink">
    <a href="#%e6%9c%80%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91" class="header-mark"></a>最小生成树</h3><ul>
<li>如何扩张？（Ch10）</li>
</ul>
<h3 id="深度优先-广度优先" class="headerLink">
    <a href="#%e6%b7%b1%e5%ba%a6%e4%bc%98%e5%85%88-%e5%b9%bf%e5%ba%a6%e4%bc%98%e5%85%88" class="header-mark"></a>深度优先 广度优先</h3><h2 id="算法设计补充" class="headerLink">
    <a href="#%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1%e8%a1%a5%e5%85%85" class="header-mark"></a>算法设计补充</h2><h3 id="贪心算法" class="headerLink">
    <a href="#%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95" class="header-mark"></a>贪心算法</h3><ul>
<li>ch10.1 分析复杂度</li>
</ul>
<h3 id="分治算法-divide-and-conquer" class="headerLink">
    <a href="#%e5%88%86%e6%b2%bb%e7%ae%97%e6%b3%95-divide-and-conquer" class="header-mark"></a>分治算法 Divide-and-Conquer</h3><ul>
<li>分而治之，递归</li>
</ul>
<h3 id="dynamic-programming" class="headerLink">
    <a href="#dynamic-programming" class="header-mark"></a>Dynamic Programming</h3><ul>
<li>ch10.3 与d-c的比较（自底向上&amp;自顶向下）</li>
</ul>
<h3 id="回溯法" class="headerLink">
    <a href="#%e5%9b%9e%e6%ba%af%e6%b3%95" class="header-mark"></a>回溯法</h3>]]></description>
</item></channel>
</rss>
